<head>
	<script type="text/javascript" src="https://www.airconsole.com/api/airconsole-1.7.0.js"></script>
	<link rel="stylesheet" href="screen.css">
	<link rel="stylesheet" href="shared.css">
	<link href="https://fonts.googleapis.com/css?family=Oswald|Roboto" rel="stylesheet">
	<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.0/jquery.min.js"></script>
	<link rel="stylesheet" href="https://ajax.googleapis.com/ajax/libs/jqueryui/1.12.1/themes/smoothness/jquery-ui.css">
	<script src="https://ajax.googleapis.com/ajax/libs/jqueryui/1.12.1/jquery-ui.min.js"></script>

	<script type="text/javascript">

		// whether or not to display all information
		const DEBUG = false;
		
		// scroll the result areas or not
		document.scroll_results = false;

		// variable to store the library in after an initial query
		var library;

		// relative to the sound effects
		document.musicVolume = 0.4;

		// store amount of correct full guesses
		document.amount_of_finished_players = 0;

		document.round = 0;
		// the setting that is used to count downwards. could potentially be modified by settings
		document.RoundTimeSetting = 30;
		document.RoundTime = document.RoundTimeSetting;
		document.maxRound = 35;

		// store current scores of players
		document.playerScores = [];

		document.inactiveClients = 0;

		document.game_in_progress = false;
		document.ad_showing = false;
		document.showing_credits = false;
		document.game_over_screen = false;
		document.playerFailed = false;

		document.low_performance = false;

		document.roundEndInitiated = false;

		document.selectedPlaylist;

		var playlists = [
			{
				name: "2000's",
				id: "11",
				description: "The best and the worst decade.",
				new: "0",
				amount_of_tracks: 314,
				album_art: [
					"album_art/1440866782.jpg",
					"album_art/291708656.jpg",
					"album_art/409547.jpg",
					"album_art/78985420.jpg"
				]
			},
			{
				name: "2010's",
				id: "26",
				description: "Music from 2010-2019",
				new: "0",
				amount_of_tracks: 191,
				album_art: [
					"album_art/487053599.jpg",
					"album_art/561758043.jpg",
					"album_art/720197924.jpg",
					"album_art/545398133.jpg"
				]
			},
			{
				name: "70's",
				id: "9",
				description: "Rock'n Roll & Funk is born",
				new: "0",
				amount_of_tracks: 140,
				album_art: [
					"album_art/1423766994.jpg",
					"album_art/1423191432.jpg",
					"album_art/1245973052.jpg",
					"album_art/355038498.jpg"
				]
			},
			{
				name: "80's",
				id: "10",
				description: "The age of MTV",
				new: "0",
				amount_of_tracks: 147,
				album_art: [
					"album_art/279020.jpg",
					"album_art/724011185.jpg",
					"album_art/853593032.jpg",
					"album_art/79565550.jpg"
				]
			},
			{
				name: "90's",
				id: "2",
				description: "Eurdance, Teen Pop, Hip Hop and Bravo Hits",
				new: "0",
				amount_of_tracks: 221,
				album_art: [
					"album_art/693198382.jpg",
					"album_art/930746388.jpg",
					"album_art/78968947.jpg",
					"album_art/253426154.jpg"
				]
			},
			{
				name: "Christmas",
				id: "60",
				description: "",
				new: "1",
				amount_of_tracks: 117,
				album_art: [
					"album_art/250589852.jpg",
					"album_art/724401288.jpg",
					"album_art/574914714.jpg",
					"album_art/1434882633.jpg"
				]
			},
			{
				name: "Dance Music",
				id: "3",
				description: "Electronic Dance Music, mostly Trance.",
				new: "0",
				amount_of_tracks: 266,
				album_art: [
					"album_art/853555448.jpg",
					"album_art/1363084610.jpg",
					"album_art/1460115839.jpg",
					"album_art/1069373811.jpg"
				]
			},
			{
				name: "Deutschland",
				id: "7",
				description: "Songs in German or from Germany",
				new: "0",
				amount_of_tracks: 168,
				album_art: [
					"album_art/14448703.jpg",
					"album_art/871733033.jpg",
					"album_art/1081942885.jpg",
					"album_art/209420563.jpg"
				]
			},
			{
				name: "Female Artists",
				id: "35",
				description: "Female artists & collaborations",
				new: "0",
				amount_of_tracks: 364,
				album_art: [
					"album_art/850004323.jpg",
					"album_art/367377657.jpg",
					"album_art/185861003.jpg",
					"album_art/1363084610.jpg"
				]
			},
			{
				name: "freakpants' list of disaster",
				id: "0",
				description: "A list of music enjoyed by the creator of MusicGuess.",
				new: "0",
				amount_of_tracks: 647,
				album_art: [
					"album_art/690928033.jpg",
					"album_art/190655957.jpg",
					"album_art/992221994.jpg",
					"album_art/357652252.jpg"
				]
			},
			{
				name: "Global Hits 2021",
				id: "15",
				description: "The most successful global hits of 2021",
				new: "0",
				amount_of_tracks: 108,
				album_art: [
					"album_art/1538646756.jpg",
					"album_art/1560071303.jpg",
					"album_art/1565442393.jpg",
					"album_art/1581892464.jpg"
				]
			},
			{
				name: "Global Hits All Time",
				id: "43",
				description: "The most successful global hits of all Time, From 1950 to today",
				new: "0",
				amount_of_tracks: 428,
				album_art: [
					"album_art/1475169095.jpg",
					"album_art/1019269187.jpg",
					"album_art/1384470408.jpg",
					"album_art/656446479.jpg"
				]
			},
			{
				name: "Hip-Hop/Rap",
				id: "21",
				description: "From Grandmaster Funk to Drake",
				new: "0",
				amount_of_tracks: 136,
				album_art: [
					"album_art/79674983.jpg",
					"album_art/14391311.jpg",
					"album_art/1476636939.jpg",
					"album_art/6655669.jpg"
				]
			},
			{
				name: "Pop Music",
				id: "1",
				description: "Music that a lot of people like",
				new: "0",
				amount_of_tracks: 663,
				album_art: [
					"album_art/713710434.jpg",
					"album_art/295931997.jpg",
					"album_art/105683.jpg",
					"album_art/528435845.jpg"
				]
			},
			{
				name: "Pop/Alternative Rock",
				id: "24",
				description: "Poprock and indie stuff",
				new: "0",
				amount_of_tracks: 211,
				album_art: [
					"album_art/1524841154.jpg",
					"album_art/1140560324.jpg",
					"album_art/716692336.jpg",
					"album_art/635770200.jpg"
				]
			},
			{
				name: "Rock & Metal",
				id: "5",
				description: "Mostly of the softer persuasion though",
				new: "0",
				amount_of_tracks: 100,
				album_art: [
					"album_art/2859605.jpg",
					"album_art/217959525.jpg",
					"album_art/214403406.jpg",
					"album_art/930321179.jpg"
				]
			},
			{
				name: "Swiss",
				id: "12",
				description: "Songs from Switzerland. mostly in Swiss German",
				new: "0",
				amount_of_tracks: 105,
				album_art: [
					"album_art/1086133342.jpg",
					"album_art/195775609.jpg",
					"album_art/415659875.jpg",
					"album_art/1342288612.jpg"
				]
			},
			{
				name: "Trance",
				id: "4",
				description: "Beats & Vocals",
				new: "0",
				amount_of_tracks: 103,
				album_art: [
					"album_art/336152488.jpg",
					"album_art/316789035.jpg",
					"album_art/453207238.jpg",
					"album_art/335774788.jpg"
				]
			},
			{
				name: "UK",
				id: "42",
				description: "Artists from the Kingdom",
				new: "0",
				amount_of_tracks: 251,
				album_art: [
					"album_art/942753719.jpg",
					"album_art/1440833098.jpg",
					"album_art/415628679.jpg",
					"album_art/947999961.jpg"
				]
			},
			{
				name: "US Hits 2020",
				id: "30",
				description: "US Hits of last year",
				new: "0",
				amount_of_tracks: 100,
				album_art: [
					"album_art/1544797363.jpg",
					"album_art/1490463311.jpg",
					"album_art/1511037323.jpg",
					"album_art/1481647240.jpg"
				]
			}
		];
		/* 			{
				name: "Wildcard",
				id: "666",
				description: "Completely uncurated random selection of songs",
				new: "1",
				amount_of_tracks: 100,
				album_art: [
					"images/question.svg",
					"images/question.svg",
					"images/question.svg",
					"images/question.svg"
				]
			}
		*/
		var air_console;

		$(document).ready(function () {
			document.getElementById("player").addEventListener('error', function failed(e) {
				// audio playback failed - show a message saying why
				// to get the source of the audio element use $(this).src
				if (e.target.error !== undefined) {
					switch (e.target.error.code) {
						case e.target.error.MEDIA_ERR_SRC_NOT_SUPPORTED:
							DEBUG && console.log('The video audio not be loaded, either because the server or network failed or because the format is not supported.');
						case e.target.error.MEDIA_ERR_ABORTED:
							DEBUG && console.log('You aborted the video playback.');
						case e.target.error.MEDIA_ERR_NETWORK:
							DEBUG && console.log('A network error caused the audio download to fail.');
						case e.target.error.MEDIA_ERR_DECODE:
							DEBUG && console.log('The audio playback was aborted due to a corruption problem or because the video used features your browser did not support.');
						default:
							DEBUG && console.log('An unknown error occurred.');
							document.playerFailed = true;
							break;
					}
				}
			}, true);
		});

		function init() {
			air_console = new AirConsole();

			// watch for new controllers connecting
			air_console.onConnect = function (device_id) {
				// let the new controller know how many rounds are currently selected
				update_selected_rounds_on_controllers();
				// also inform the new controller of the current limit for the selected playlist
				update_max_rounds_on_controllers();

				// update_controllers_about_game_status();

				// we actually need to do this on game start as well, for every client, since we delete the areas after the game
				initiate_guessing_area(device_id);


				/* prepare messages for clients */
				show_menu = [];
				show_menu.push({
					type: "show_menu"
				});
				hide_menu = [];
				hide_menu.push({
					type: "hide_menu"
				});
				inactive = [];
				inactive.push({
					type: "inactive"
				});
				show_back_from_credits = [];
				show_back_from_credits.push({
					type: "show_back_from_credits"
				});
				show_back_to_main = [];
				show_back_to_main.push({
					type: "show_back_to_main"
				});

				// check if there is currently a round in progress
				if (document.round > 0 && !document.roundEndInitiated && !document.game_over_screen) {
					DEBUG && console.log("we a currently in a game");
					// let the new client know to display the please wait message (instead of waiting for master controller)
					air_console.message(device_id, inactive);
					// store the fact that we have an inactive client in this round
					document.inactiveClients += 1;
				} else if (document.game_over_screen) {
					DEBUG && console.log("we are currently showing the game over screen");
					// if the client is master, direct him to show the back to main
					if (air_console.getMasterControllerDeviceId() !== undefined && air_console.getMasterControllerDeviceId() === device_id) {
						air_console.message(device_id, show_back_to_main);
					} else {
						// otherwise, just show the regular waiting for start
						air_console.message(device_id, hide_menu);
					}
				} else if (document.showing_credits) {
					DEBUG && console.log("we are currently showing credits");
					// if we are currently showing credits, let the client know what to display
					// if the client is master, direct him to show the back from credits
					if (air_console.getMasterControllerDeviceId() !== undefined && air_console.getMasterControllerDeviceId() === device_id) {
						air_console.message(device_id, show_back_from_credits);
					} else {
						// otherwise, just show the regular waiting for start
						air_console.message(device_id, hide_menu);
					}
				} else {
					DEBUG && console.log("There is no round in progress, and we are not showing credits");
					// if there is no round in progress, check if the connected device is the master
					if (air_console.getMasterControllerDeviceId() !== undefined && air_console.getMasterControllerDeviceId() === device_id) {
						DEBUG && console.log("device " + device_id + " is the master");
						// let the new client know to display the menu)
						air_console.message(device_id, show_menu);
						// also let all other clients know NOT to display the menu anymore
						air_console.getControllerDeviceIds().forEach(function (id) {
							if (id === device_id) return;
							air_console.message(id, hide_menu);
						});
					} else {
						DEBUG && console.log("device " + device_id + " is not a master");
						air_console.message(device_id, hide_menu);
					}

				}
			};

			air_console.onDisconnect = function (device_id) {
				// update_controllers_about_game_status();
				// check if there is currently a round in progress
				if (document.round > 0 && !document.roundEndInitiated && !document.game_over_screen) {
					// do nothing?
				} else if (document.game_over_screen) {
					// let the new master know to display the back to main
					if (air_console.getMasterControllerDeviceId() !== undefined) {
						DEBUG && console.log("informing new master to show the back to main button");
						message = [];
						message.push({
							type: "show_back_to_main"
						});
						air_console.message(air_console.getMasterControllerDeviceId(), message);
					}
				} else if (document.showing_credits) {
					// let the new master know to display the back from credits
					if (air_console.getMasterControllerDeviceId() !== undefined) {
						DEBUG && console.log("informing new master to show the back to credits button");
						message = [];
						message.push({
							type: "show_back_from_credits"
						});
						air_console.message(air_console.getMasterControllerDeviceId(), message);
					}
				} else {
					// let the new master know to display the menu
					if (air_console.getMasterControllerDeviceId() !== undefined) {
						message = [];
						message.push({
							type: "show_menu"
						});
						air_console.message(air_console.getMasterControllerDeviceId(), message);
					}
				}
			}

			// Listen for messages from other devices
			air_console.onMessage = function (from, message) {
				// handle message
				var type = message[0].type;
				DEBUG && console.log('handling ' + type + ' message on screen.');

				switch (type) {
					case 'credits':
						$("#game_logo").animate({ fontSize: "80px" }, 1500);
						$("#playlist-selector").hide("fade", {}, 1500);
						$("#credits-container").show();
						$("#credits").css({ display: "flex" });
						sleep(1500).then(() => {
							document.showing_credits = true;
							$("#credits").animate({ opacity: 1 }, 1500);
						});
						break;
					case 'startGame':
						// start the game
						document.getElementById("sound-effect-start").play();
						start();
						break;
					case 'correctGuess':
						// play the correct guess sound
						document.getElementById("sound-effect-correct").play();
						// deal with the score changes etc
						if (!document.cancelled) {
							handle_guess(message, from);
						}
						break;
					case 'wrongGuess':
						// play the wrong guess sound
						document.getElementById("sound-effect-wrong").play();
						// deal with the score changes etc
						if (!document.cancelled) {
							handle_guess(message, from);
						}
						break;
					case 'next_playlist':
						switch_playlist('next');
						break;
					case 'previous_playlist':
						switch_playlist('previous');
						break;
					case 'decrease_rounds':
						document.getElementById("sound-effect-click").play();
						document.maxRound = document.maxRound - 1;
						update_selected_rounds_on_controllers();
						break;
					case 'increase_rounds':
						// check if the maximum amount of rounds for this playlist has been reached or not
						if (playlists[document.selectedPlaylist] !== undefined &&
							((document.maxRound) == playlists[document.selectedPlaylist]['amount_of_tracks'])) {
							// dont increase
						} else {
							document.getElementById("sound-effect-click").play();
							document.maxRound = document.maxRound + 1;
							update_selected_rounds_on_controllers();
						}
						break;
					case 'back_from_credits':

						$("#credits").animate({ opacity: 0 }, 1500);
						$("#game_logo").animate({ fontSize: "115px" }, 1500);

						/* back_to_main = [];
						back_to_main.push({ type: "back_to_main" });
						air_console.broadcast(back_to_main); */

						sleep(1500).then(() => {
							document.showing_credits = false;
							$("#credits").hide();
							$("#credits-container").hide();

							$("#playlist-selector").show("fade", {}, 1500);
						});
						break;
					case 'cancel':
						$("#message").html("");
						$("#message").hide();
						$("#roundCounter").hide();
						$("#playlist-display").hide();
						// inform other controllers
						hide_menu = [];
						hide_menu.push({
							type: "hide_menu"
						});

						// in case some controllers were still waiting
						sleep(2000).then(() => {
							air_console.broadcast(hide_menu);
						});

						document.cancelled = true;
						document.roundEndInitiated = true;

						document.amount_of_finished_players = 0;

						document.game_in_progress = false;
						document.game_over_screen = false;

						player = document.getElementById("player");
						player.volume = 0;

						$("#roundTime").hide();
						$("#current_song_service").hide();
						$("#playanimation").hide();

						// reset the results area and the round status
						$("#results-scrollable").html("");
						$("#status").hide();
						$("#status").html("");

						$("#victory_screen").hide();
						$("#victory_screen").html("");

						$("#game_logo").show("fade", {}, 1500);
						$("#playlist-selector").show("fade", {}, 1500);
						break;
					case 'back_to_main':
						$("#message").html("");
						// $("#message").hide("fade", {}, 1500);

						document.game_in_progress = false;
						document.game_over_screen = false;

						// reset the results area and the round status
						$("#results-scrollable").html("");
						$("#status").hide();
						$("#status").html("");

						$("#victory_screen").hide();
						$("#victory_screen").html("");

						/* back_to_main = [];
						back_to_main.push({ type: "back_to_main" }); */

						$("#game_logo").show("fade", {}, 1500);
						$("#playlist-selector").show("fade", {}, 1500);

						// air_console.broadcast(back_to_main);

						break;
				}
			};

			air_console.onAdShow = function () {
				DEBUG && console.log("ad has started showing");
				document.ad_showing = true;
			};

			air_console.onAdComplete = function (ad_was_shown) {
				DEBUG && console.log("onAdComplete is triggered");
				document.ad_showing = false;
				document.roundEndInitiated = true;
				next_round();
			};

			// get the playlists info
			// $.ajax({ method: "GET", url: "playlists/playlist_info.json", data: {}, dataType: "json" })
			// .done(function (msg) {
			// playlists = msg;
			// display info for the first playlist

			html = '';
			counter = 0;
			middle_id = Math.floor(playlists.length / 2);

			/* playlists.forEach(function (playlist) {
				DEBUG && console.log("loading playlist");
				DEBUG && console.log(playlist);
				if (counter === middle_id) {
					// defaults to popular stuff
					document.selectedPlaylist = counter;
					update_max_rounds_on_controllers();
					html += '<div id="playlist_' + counter + '" data-html-id="' + counter + '" class="album_art active">';
				} else {
					html += '<div id="playlist_' + counter + '" data-html-id="' + counter + '" class="album_art">';
				}

				if (air_console !== undefined) {
					air_console.devices.forEach(device_object => {
						if (device_object !== undefined && device_object !== null && device_object.client !== null && device.client.low_performance) {
							document.low_performance = true;
						}
					});
				}

				// dont even add the images on the gamehub app
				if (!document.low_performance) {
					playlist.album_art.forEach(function (element) {
						html = html + '<img src="' + element + '" />';
					});
					$("#screen-wrapper").append('<img id="playanimation" src="audio.svg" />');
					$("body").append('<video playsinline autoplay muted loop id="bgvid"><source src="videos/disco_loop.mp4" type="video/mp4"></video>');
					if (playlist.new === "1") {
						html = html + '<span class="new-sticker">NEW!</span>';
					}
				}

				html += '<div class="playlist-text"><b>' + playlist.name + '</b>';
				html += playlist.amount_of_tracks + ' Tracks</br>';
				html += '<span class="playlist-description">' + playlist.description + '</span>';
				html += '</div>';
				html += '</div>';
				counter++;
			}); */

			document.selectedPlaylist = 1;
			update_max_rounds_on_controllers();

			DEBUG && console.log(playlists);

			if (air_console !== undefined) {
				air_console.devices.forEach(device_object => {
					if (device_object !== undefined && device_object !== null && device_object.client !== null && device.client.low_performance) {
						document.low_performance = true;
					}
				});
			}

			var add_to_storage_only = false;
			document.playlist_storage = [];
			var playlist_html;

			$("#screen-wrapper").append('<img id="playanimation" src="audio.svg" />');
			$("body").append('<video playsinline autoplay muted loop id="bgvid"><source src="videos/disco_loop.mp4" type="video/mp4"></video>');

			playlists.every(function (playlist) {

				if (counter > 2) {
					add_to_storage_only = true;
				}
				DEBUG && console.log("loading playlist");
				DEBUG && console.log(playlist);
				DEBUG && console.log(playlist.name);
				if (!add_to_storage_only) {
					switch (counter) {
						case 0:
							html += '<div id="playlist_' + counter + '" data-html-id="' + counter + '" class="album_art previous">';
							break;
						case 1:
							html += '<div id="playlist_' + counter + '" data-html-id="' + counter + '" class="album_art active">';
							break;
						case 2:
							html += '<div id="playlist_' + counter + '" data-html-id="' + counter + '" class="album_art next">';
							break;
					}
				}

				playlist_html = '';
				// dont even add the images on the gamehub app
				// document.low_performance = true;
				if (!document.low_performance) {
					playlist.album_art.forEach(function (element) {
						if (!add_to_storage_only) {
							html = html + '<img src="' + element + '" />';
						}
						playlist_html += '<img src="' + element + '" />';
					});
					if (playlist.new === "1") {
						if (!add_to_storage_only) {
							html = html + '<span class="new-sticker">NEW!</span>';
						}
						playlist_html += '<span class="new-sticker">NEW!</span>';
					}
				}

				if (!add_to_storage_only) {
					html += '<div class="playlist-text-wrapper"><div class="playlist-text">' + playlist.name;
				}
				playlist_html += '<div class="playlist-text-wrapper"><div class="playlist-text">' + playlist.name;
				if (counter === 1) {
					details = '<div id="details-wrapper"><div id="playlist-details"><span class="playlist-track-count">' + playlist.amount_of_tracks + ' Tracks</span>';
					details += '<span class="playlist-description">' + playlist.description + '</span></div></div>';
				}
				if (!add_to_storage_only) {
					html += '</div></div>';
					html += '<div id="disc-hole-wrapper" ><div id="disc-hole"></div></div>';
					html += '</div>';
				}

				playlist_html += '</div></div>';
				playlist_html += '<div id="disc-hole-wrapper" ><div id="disc-hole"></div></div>';
				playlist_html += '</div>';

				document.playlist_storage[counter] = playlist_html;

				counter++;
				return true;
			});

			DEBUG && console.log(document.playlist_storage);

			$("#playlist-selector").html(html);
			$("#playlist-selector").append(details);
			$("#playlist-selector").css("display", "flex");

			// go to a specific playlist (workaround until rewrite)
			// switch_playlist("previous");
			switch_playlist("next");
			switch_playlist("next");
			switch_playlist("next");
			switch_playlist("next");

			//	});
		}

		function calculateRoundTime() {

			// calculate the difference between the start of the round and now
			currentTime = new Date().getTime();
			timePassed = Math.floor((currentTime - document.RoundStartTime) / 1000);
			// substract the time passed from the roundtime setting (30 secs unless set otherwise)
			document.RoundTime = document.RoundTimeSetting - timePassed;
			// display the current time on the UI
			$("#roundTime").html(document.RoundTime);

			if (document.RoundTime === 6 && !document.animatingVolume) {
				document.animatingVolume = true;
				$("#player").animate({ volume: 0 }, 6000);
			}

			// if in an active round, since a disconnect isnt registered instantly, keep checking if the round is actually already over
			if (document.round > 0 && !document.roundEndInitiated) {
				check_if_all_players_have_guessed();
			}

			if (document.playerFailed) {
				DEBUG && console.log("player failed, skipping song");
				$("#roundTime").hide();
				$("#message").html("Broken song, skipping!");

				skipping = [];
				skipping.push({ type: "skipping" });
				air_console.broadcast(skipping);
				document.roundEndInitiated = true;
				round_end();
			}

			// this generates a whole lot of log lines, because it is calling itself permanently
			// DEBUG && console.log("roundendinitiated: " + document.roundEndInitiated);
			if (document.RoundTime > 0 && document.roundEndInitiated === false) {
				// this generates a whole lot of log lines, because it is calling itself permanently
				// DEBUG && console.log("checking if we are out of time");
				setTimeout(calculateRoundTime, 0);
			} else if (document.roundEndInitiated === false) {
				DEBUG && console.log("out of time");
				// give 30 seconds to everyone who did not guess
				air_console.getControllerDeviceIds().forEach(function (id) {
					// try selecting current score
					playerScore = document.playerScores.filter(function (obj) {
						return obj.player === id;
					});

					if (playerScore[0]) {
						playerScore[0].currentGuessTime = 30;
						playerScore[0].totalGuessTime += 30;
					} else {
						initialize_player_score(id, 0, 30, 30, false);
					}
				});

				// time has run out, tell the remaining controllers to also switch to the round over state
				out_of_time = [];
				out_of_time.push({ type: "out_of_time" });
				air_console.broadcast(out_of_time);
				document.roundEndInitiated = true;
				round_end();
			}
		}

		function initiateScrollingCheck() {
			// check if the guessing area needs to scroll
			determine_result_area_size();
			// call the function itself again
			if (document.game_in_progress) {
				setTimeout(initiateScrollingCheck, 475);
			}
		}

		document.scroll_in_progress = false;
		document.last_scroll_direction = "left";
		document.last_scroll_ended = new Date().getTime();

		function scroll() {
			currentTime = new Date().getTime();
			timePassed = Math.floor((currentTime - document.last_scroll_ended) / 1000);

			if (document.scroll_results && !document.scroll_in_progress && timePassed >= 1) {
				document.scroll_in_progress = true;
				scrollTime = 1000 * document.overlapping_result_areas;
				scrollDistance = $(".single-result").first().outerWidth(true) * -1 * document.overlapping_result_areas;


				if (document.last_scroll_direction == 'right') {
					$("#results-scrollable").animate({ left: scrollDistance + 'px' }, scrollTime, function () {
						document.last_scroll_direction = "left";
						document.scroll_in_progress = false;
						document.last_scroll_ended = new Date().getTime();
					});
				} else {
					$("#results-scrollable").animate({ left: '0px' }, scrollTime, function () {
						document.last_scroll_direction = "right";
						document.scroll_in_progress = false;
						document.last_scroll_ended = new Date().getTime();
					});
				}
				// console.log("scrolling " + scrollDistance + "px for " + scrollTime + " milliseconds.");
			}
		}

		function determine_result_area_size() {
			// this function checks whether or not we need to make the result area scrollable

			full_window_width = $(window).width();
			// substract the size of the timer
			available_area_width = full_window_width - $("#roundTime").outerWidth(true);

			single_result_area_width = $(".single-result").first().outerWidth(true);
			// console.log("size of one result area: " + single_result_area_width);
			number_of_possible_result_areas = Math.floor(available_area_width / single_result_area_width);
			// console.log("amount of result areas that fit onto the screen before scrolling: " + number_of_possible_result_areas);

			// set the size of the result area so there are no cut off result areas (unless scrolling of course)
			$("#player-results").width(number_of_possible_result_areas * single_result_area_width);
			// also set the margins of the result area, so it is centered on the available space
			// results_margin_left = (available_area_width - $("#player-results").width()) / 2;
			// $("#player-results").css('margin-left', results_margin_left + 'px')
			// console.log("margin: " + results_margin_left);

			number_of_actual_result_areas = $(".single-result").length;
			// console.log("amount of result areas: " +  number_of_actual_result_areas);

			document.overlapping_result_areas = number_of_actual_result_areas - number_of_possible_result_areas;

			// check if a line break is happening
			if (number_of_actual_result_areas > number_of_possible_result_areas) {
				// console.log("line break is happening!");
				// store last amount of overlapping areas for reset purposes
				document.last_overlap_amount = document.overlapping_result_areas;
				if (!document.scroll_in_progress) {
					document.scroll_results = true;
					scroll();
				}
			} else {
				// disable the scrolling
				if (!document.scroll_in_progress && document.last_scroll_direction == "left") {
					document.scroll_in_progress = true;
					// scroll back to initial position
					scrollTime = 1000 * document.last_overlap_amount;
					$("#results-scrollable").animate({ left: '0px' }, scrollTime, function () {
						document.last_scroll_direction = "right";
						document.scroll_in_progress = false;
						document.last_scroll_ended = new Date().getTime();
					});
				}
				document.scroll_results = false;
			}
			// console.log("size of full window: " + full_window_width);	
		}

		function start() {

			DEBUG && console.log("start function initiated");
			document.cancelled = false;

			// reset in case we cancelled an earlier game
			document.roundEndInitiated = false;

			// inform controllers to display get ready
			get_ready = [];
			get_ready.push({ type: "get_ready" });
			air_console.broadcast(get_ready);

			// reset guessing areas
			$("#results-scrollable").html("");

			// create guessing areas for all controllers
			const device_ids = air_console.getControllerDeviceIds();
			device_ids.forEach(function (id) {
				initiate_guessing_area(id);
			});

			// fade logo and playlist selector
			$("#game_logo,#playlist-selector").hide("fade", {}, 1500);


			sleep(1500).then(() => {

				// show message again (may have been hidden by end of game)
				$("#message").css({ display: "flex" });
				$("#status").css({ display: "flex" });

				$("#message").html("Get ready for the first round!");
				$("#status").html("3");
				document.getElementById("sound-effect-clock").play();
				sleep(1000).then(() => {
					document.getElementById("sound-effect-clock").play();
					$("#status").html("2");
					sleep(1000).then(() => {
						document.getElementById("sound-effect-clock").play();
						$("#status").html("1");
						sleep(1000).then(() => {

							$("#roundCounter").html("Round</br>1/" + document.maxRound);
							$("#playlist-display").html(playlists[document.selectedPlaylist].name);
							$("#playlist-display").css({ display: "flex" });
							$("#roundCounter").css({ display: "flex" });
							$("#status").hide();
							$("#status").html("");

							document.game_in_progress = true;

							// start the function that keeps initiating the check for the result areas
							initiateScrollingCheck();

							// reset scores of players
							document.playerScores = [];

							// reset the roundTime again, at the actual start of the round
							document.RoundTime = document.RoundTimeSetting;
							// also reset the startTime of the current Round so we can keep track of how many seconds have passed
							document.RoundStartTime = new Date().getTime();

							// initiate round time keeptracker
							calculateRoundTime();

							document.round = 0;
							$("#player-results").show();
							$("#roundTime").html(document.RoundTime);
							$("#roundTime").css("display", "flex");

							// override screen with play area
							$("#message").html("Guess the artist or title that is currently playing!");
							$("#playanimation").show();
							$("#current_song_service").show();

							document.playerFailed = false;

							DEBUG && console.log("getting ready to call ajax for playlist");
							// get list of songs, choose one at random
							if (playlists[document.selectedPlaylist].id === "666") {
								$.ajax(
									{
										method: "GET",
										url: "https://zxxwemywpv.cyon.link/musicguess-data/php/get_wildcard.php",
										data: {}, dataType: "json", crossDomain: true, "headers": {
											"accept": "application/json",
										}
									})
									.done(function (msg) {
										DEBUG && console.log("ajax for playlist is done");
										library = msg;
										library_copy_for_wrong_answers = library.slice();
										// console.log(library);
										DEBUG && console.log("playing random song for the first time");

										play_random_song();
									})
									.fail(function (msg) {
										DEBUG && console.log("ajax for playlist failed");
										start();
									}
									);
							} else {
								$.ajax(
									{ method: "GET", url: "playlists/playlist_" + playlists[document.selectedPlaylist].id + ".json", data: {}, dataType: "json" })
									.done(function (msg) {
										DEBUG && console.log("ajax for playlist is done");
										library = msg;
										library_copy_for_wrong_answers = library.slice();
										// console.log(library);
										DEBUG && console.log("playing random song for the first time");

										play_random_song();
									})
									.fail(function (msg) {
										DEBUG && console.log("ajax for playlist failed");
										start();
									}
									);
							}

							var playlist_id = playlists[document.selectedPlaylist].id;
							DEBUG && console.log("trying to send playlist selected event");
							$.ajax(
									{
										method: "POST",
										url: "https://zxxwemywpv.cyon.link/musicguess-data/php/playlist-selected.php",
										data: { devices: air_console.devices, playlist_id: playlist_id }, dataType: "json", crossDomain: true, "headers": {}
									}); 


							// stores the current solution
							document.solution = [];
						});
					});
				});
			});
		}

		// Array Remove - By John Resig (MIT Licensed)
		Array.prototype.remove = function (from, to) {
			var rest = this.slice((to || from) + 1 || this.length);
			this.length = from < 0 ? this.length + from : from;
			return this.push.apply(this, rest);
		};

		function randomIntFromInterval(min, max) {
			return Math.floor(Math.random() * (max - min + 1) + min);
		}

		/* function update_controllers_about_game_status(){
		message = [];
		if (document.game_in_progress) {
			// let the existing controllers know the game is running
			
			message.push({
				type: "in_progress"
			});
			
		} else {
			// let the existing controllers know the game is not running
			message.push({
				type: "not_in_progress"
			});
		}
		air_console.broadcast(message);
		} */

		function play_random_song() {
			DEBUG && console.log("play random song was called");
			document.round++;
			DEBUG && console.log("increased round counter");
			$("#roundCounter").html("Round</br>" + document.round + "/" + document.maxRound);
			DEBUG && console.log("set round counter display");

			// test if the start function can be invoked in case of library not being loaded successfully from ajax
			// it does, just not very nicely
			/* randonum = randomIntFromInterval(0,1);
			if(randonum === 0){
				console.log("bugging out");
				library = undefined;
			} else {
				console.log("working");
			} */
			DEBUG && console.log("library:");
			DEBUG && console.log(library);
			if (library === undefined) {
				// attempt to start over
				DEBUG && console.log("starting over because library was not returned from ajax");
				start();
				return;
			}

			randomSongIndex = randomIntFromInterval(0, library.length - 1);
			DEBUG && console.log("got id of random song");
			randomSong = library[randomSongIndex];

			// use this to select a specific song
			/* library.forEach((track) => {
				if(track.id === '1054438586'){
					randomSong = track;
				}
			}); */

			DEBUG && console.log("random song:");
			DEBUG && console.log(randomSong);

			DEBUG && console.log("got the random song object");
			// remove song from the library so it will not get played more than once
			library.remove(randomSongIndex);
			DEBUG && console.log("removed the random song from the library");

			// get wrong answers for multiple choice
			wrong_answers = 0;
			wrong_answers_array = [];
			artist_or_title = randomIntFromInterval(0, 1);
			DEBUG && console.log("determined whether to let the user guess artist or title");

			DEBUG && console.log("entering while loop");

			while (wrong_answers < 3) {

				// 50:50 chance that wrong answer is either artist or title

				suitable_wrong_answer = true;
				wrongSongIndex = randomIntFromInterval(0, library_copy_for_wrong_answers.length - 1);

				// console.log("wrong song index " + wrongSongIndex);

				wrongSong = library_copy_for_wrong_answers[wrongSongIndex];
				if (artist_or_title === 0) {
					// artist
					// check if the wrongSong has the same artist as the actual song
					if (wrongSong === undefined || randomSong === undefined) {
						suitable_wrong_answer = false;
					} else if (wrongSong.artist === randomSong.artist) {
						suitable_wrong_answer = false;
					}
					// check if wrong contains right, or vice versa
					if (wrongSong.artist.indexOf(randomSong.artist) !== -1 && randomSong.artist.indexOf(wrongSong.artist)) {
						suitable_wrong_answer = false;
					}
					// check if the selection is already in the array
					if ($.inArray(wrongSong.artist, wrong_answers_array) !== -1) {
						suitable_wrong_answer = false;
					}
					if (suitable_wrong_answer) {
						wrong_answers_array.push(wrongSong.artist);
					}
				} else {
					// title
					// check if the wrongSong has the same title as the actual song
					if (wrongSong.title === randomSong.title) {
						suitable_wrong_answer = false;
					}
					// check if wrong contains right, or vice versa
					if (wrongSong.title.indexOf(randomSong.title) !== -1 && randomSong.title.indexOf(wrongSong.title) !== -1) {
						suitable_wrong_answer = false;
					}
					// check if the selection is already in the array
					if ($.inArray(wrongSong.title, wrong_answers_array) !== -1) {
						suitable_wrong_answer = false;
					}
					if (suitable_wrong_answer) {
						wrong_answers_array.push(wrongSong.title);
					}
				}
				if (suitable_wrong_answer) {
					wrong_answers++;
				}
			}

			// console.log("array of wrong answers" + wrong_answers_array);

			// console.log("playing song " + randomSongIndex + " in library");
			// console.log(randomSong);

			// change song id in player
			$("#player").attr("src", randomSong.preview_url);

			// turn volume back up
			DEBUG && console.log("resetting player volume");
			document.animatingVolume = false;
			player = document.getElementById("player");
			player.volume = 0.4;

			// apparently this is broken?
			// $("#player").prop("volume", 0.4);


			// record start time
			document.startTime = new Date().getTime();


			// $('#player').get(0).currentTime = 5;
			$("#playanimation").show();
			DEBUG && console.log("triggered the bars animation");


			artist = randomSong.artist;
			title = randomSong.title;
			album = randomSong.album;
			album_art = randomSong.album_art;
			buy_link = randomSong.buy_link;

			$("#current_song_service").html("<div id='disclaimer'>This song is provided by the Itunes Search API Preview</div><div id='get_it_link'><a href='" + buy_link + "'' target='_blank'><img src='images/itunes.svg' class='itunes' /></a></div>");



			document.solution = [];
			document.solution.push({
				type: "solution",
				artist: artist,
				title: title,
				album: album,
				album_art: album_art,
				wrongAnswers: wrong_answers_array,
				answerType: artist_or_title,
				buy_link: buy_link
			});

			// send the solution to all clients
			air_console.broadcast(document.solution);
		}

		function switch_playlist(type) {
			// console.log("Handling switch of playlist to " + type);
			// console.log("all playlists:");
			// console.log(playlists);

			// $(".album_art.active").addClass("shrink");

			document.getElementById("sound-effect-switch").play();

			if (type === "next") {
				// currently on the last playlist
				if (document.selectedPlaylist === playlists.length - 1) {
					document.selectedPlaylist = 0;
					previous_id = playlists.length - 1;
					next_id = 1;
				} else if (document.selectedPlaylist === playlists.length - 2) {
					DEBUG && console.log("we are on the second last playlist before the switch");
					previous_id = playlists.length - 2;
					document.selectedPlaylist = playlists.length - 1;
					next_id = 0;
				} else {
					previous_id = document.selectedPlaylist;
					document.selectedPlaylist += 1;
					next_id = document.selectedPlaylist + 1;
				}
			} else {
				// previous
				// currently on the first playlist
				if (document.selectedPlaylist === 0) {
					previous_id = playlists.length - 2;
					document.selectedPlaylist = playlists.length - 1;
					next_id = 0;
				} else if (document.selectedPlaylist === 1) {
					next_id = 1;
					document.selectedPlaylist = 0;
					previous_id = playlists.length - 1;
				}
				else {
					next_id = document.selectedPlaylist;
					document.selectedPlaylist -= 1;
					previous_id = document.selectedPlaylist - 1;
				}
			}

			$(".album_art.previous").html(document.playlist_storage[previous_id]);
			$(".album_art.active").html(document.playlist_storage[document.selectedPlaylist]);

			$(".playlist-track-count").html(playlists[document.selectedPlaylist]['amount_of_tracks'] + " Tracks");
			$(".playlist-description").html(playlists[document.selectedPlaylist]['description']);


			$(".album_art.next").html(document.playlist_storage[next_id]);

			if (document.maxRound > playlists[document.selectedPlaylist]['amount_of_tracks']) {
				document.maxRound = playlists[document.selectedPlaylist]['amount_of_tracks'];
			}

			update_max_rounds_on_controllers();

			// console.log("newly selected playlist" + document.selectedPlaylist);

		}
		function update_selected_rounds_on_controllers() {
			round_change = [];
			round_change.push({ type: "round_change", maxRound: document.maxRound });
			// send round change message to the controllers
			air_console.broadcast(round_change);
		}

		function update_max_rounds_on_controllers() {
			// also send the current playlist max rounds to the controllers, so it knows when not to increase the count locally
			if (typeof playlists !== 'undefined' && document.selectedPlaylist !== undefined) {
				// only attempt this is playlists is already initialized (takes some time because the json needs to be fetched first)
				playlist_rounds = [];
				playlist_rounds.push({ type: "playlist_rounds", playlist_rounds: playlists[document.selectedPlaylist]['amount_of_tracks'] });
				air_console.broadcast(playlist_rounds);
			}
		}

		function sleep(ms) {
			return new Promise(resolve => setTimeout(resolve, ms));
		}

		function send_score() {
			document.playerScores.forEach(function (score) {
				DEBUG && console.log("sending score to player " + score.player);
				DEBUG && console.log(score);
				score_message = [];
				score_message.push({ type: "score", score: score, maxRound: document.maxRound });
				air_console.message(score.player, score_message);
			});
		}

		function round_end() {
			/* if (document.ad_showing) {
				document.roundEndInitiated = false;
				return;
			} */

			hide_cancel = [];
			hide_cancel.push({ type: "hide_cancel" });
			air_console.broadcast(hide_cancel);

			DEBUG && console.log("round end function was called");

			// determine fastest player
			// clone array for sorting differently
			fastestPlayers = document.playerScores.slice();

			fastestPlayers.sort(function (a, b) {
				if (a.currentGuessTime < b.currentGuessTime) {
					if (a.correct) {
						// place a higher than b
						return -1;
					} else if (b.correct) {
						// place b higher than a
						return 1;
					} else {
						// place a higher than b
						return -1;
					}
				}
				if (a.currentGuessTime > b.currentGuessTime) {
					if (b.correct) {
						// place b higher than a
						return 1;
					} else if (a.correct) {
						// place a higher than b
						return -1;
					} else {
						// place b higher than a
						return 1;
					}
				}
				// place and b "equally"
				if (a.correct && b.correct) {
					return 0;
				}
				if (!a.correct && !b.correct) {
					return 0;
				}
				if (a.correct) {
					// place a higher than b
					return -1;
				} else {
					// place b higher than a
					return 1;
				}

			});
			if (typeof fastestPlayers !== 'undefined' && typeof fastestPlayers[0] !== 'undefined' && fastestPlayers[0].correct) {
				fastestString = "Fastest player: " + air_console.getNickname(fastestPlayers[0].player) + " with " + fastestPlayers[0].currentGuessTime + " seconds.";
			} else if (document.playerFailed) {
				fastestString = "We apologize for the inconvenience.";
			} else {
				fastestString = "Nobody guessed correctly!";
			}
			// output fastest player to screen
			$("#status").css({ display: "flex" });
			$("#status").html(fastestString);
			// console.log(fastestString);

			// stop animations in progress
			// $("#player").stop();

			// reset the roundTime so time cant run out in the time between matches
			document.RoundTime = document.RoundTimeSetting;
			$("#roundTime").hide();

			$("#current_song_service").hide();

			$("#playanimation").hide();

			if (document.playerFailed) {
				document.playerFailed = false;
				$("#message").html("Skipped a broken song.");
				$("#roundTime").hide();
				$("#playanimation").hide();
			} else {
				if (!document.animatingVolume) {
					$("#player").animate({ volume: 0 }, 4000);
					document.animatingVolume = true;
				}

				$("#message").html("Round is over!");
			}

			sleep(4000).then(() => {



				document.amount_of_finished_players = 0;

				// remove correct/wrong classes - we wait for the timer to pass because otherwise the last players result wont get highlighted on the screen
				$(".darken_image").removeClass("avatar_wrong");
				$(".darken_image").removeClass("avatar_correct");

				if (document.round === document.maxRound) {
					// reset current round to 0 so no part of the game thinks we are still in a game
					document.round = 0;

					// handle end of game
					document.game_in_progress = false;
					document.game_over_screen = true;

					// let every player know their score for their after game report
					document.playerScores.forEach(function (score) {
						DEBUG && console.log("sending score to player " + score.player);
						DEBUG && console.log(score);
						score_message = [];
						score_message.push({ type: "score_report", score: score, maxRound: document.maxRound });
						air_console.message(score.player, score_message);
					});

					$("#roundCounter").hide();
					$("#roundCounter").html("");

					$("#playlist-display").hide();

					$("#status").html("");
					$("#status").hide();
					const winner_object = document.playerScores[0];
					let message = '';
					if (winner_object !== undefined) {
						const winner = air_console.getNickname(winner_object.player);
						const winner_correct = winner_object.correctGuesses;

						const winner_html = $("#results-scrollable .single-result").first();
						$("#victory_screen").append("<span class='game_over'> Game Over! Winner:</span>");
						$("#victory_screen").append(winner_html);

						$("#victory_screen .position_display").hide();
						$("#victory_screen .darken_image").hide();
						$("#victory_screen .player_score").append(" points");


						message += "<span class='result_category'>Correct guesses:</span>";
						message += "<span class='result'>" + winner_correct + "/" + document.maxRound + " (" + Math.round(100 / document.maxRound * winner_correct) + "%)</span></br>";
						message += "<span class='result_category'>Total time taken for guesses:</span>";
						message += "<span class='result'>" + Math.round(winner_object.totalGuessTime * 10) / 10 + " seconds</span></br>";
						message += "<span class='result_category'>Average time guessing:</span>";
						message += "<span class='result'>" + + Math.round(winner_object.totalGuessTime / document.maxRound * 10) / 10 + " seconds</span></br>";

						$("#victory_screen").append(message);

						$("#message").html("");
						$("#message").hide();
						$("#status").hide();

						$("#victory_screen").css({ display: "flex" });
						$("#victory_screen").animate({ opacity: 0.9 }, 1500);
						$("#player-results").hide();



						document.getElementById("sound-effect-cheers").play();
					} else {
						message = "Game Over!</br> You have managed to never even guess. Either you're away from the game or you're testing an edge case ;)</br>";
						$("#message").html(message);
					}


					// set roundTime extra high so the end doesnt happen more than once
					document.RoundTime = -10;
					// console.log("game over");

					$("#current_song_service").hide();

					game_end = [];
					game_end.push({ type: "game_end" });
					document.roundEndInitiated = false;
					// send game end message to the controllers
					air_console.broadcast(game_end);
				} else if (!document.cancelled) {
					air_console.showAd();
				}
			});
		}

		function next_round() {
			// stop the volume from going down
			// $("#player").stop();

			document.roundEndInitiated = false;
			// initiate next round
			// reset the number of inactive clients (clients that connect in this time can play the next round)
			document.inactiveClients = 0;
			$("#message").html("Get ready for the next round!");
			$("#status").css({ display: "flex" });
			$("#status").html("3");
			document.getElementById("sound-effect-clock").play();
			sleep(1000).then(() => {
				document.getElementById("sound-effect-clock").play();
				$("#status").html("2");
				sleep(1000).then(() => {
					document.getElementById("sound-effect-clock").play();
					$("#status").html("1");
					sleep(1000).then(() => {
						$("#current_song_service").show();
						$("#status").html("");
						$("#status").hide();
						$("#message").html("Guess the artist or title that is currently playing!");

						// reset the roundTime again, at the actual start of the round
						document.RoundTime = document.RoundTimeSetting;
						// also reset the startTime of the current Round so we can keep track of how many seconds have passed
						document.RoundStartTime = new Date().getTime();

						// reset the guessTime and correct/false for every player in case they dont answer
						document.playerScores.forEach(function (element) {
							element.correct = false;
							element.currentGuessTime = 0;
						});

						// initiate round time keeptracker
						document.roundEndInitiated = false;
						DEBUG && console.log("start keeping track of roundtime");
						calculateRoundTime();

						$("#roundTime").css("display", "flex");
						DEBUG && console.log("calling play random song for next round");
						play_random_song();
					});
				});
			});
		}

		function initiate_guessing_area(player_id) {
			// check if the player already has a guess area
			guessArea = false;
			$("#player_" + player_id + "_result").each(function () {
				guessArea = true;
			});
			if (!guessArea) {
				// determine nickname of player
				nickname = air_console.getNickname(player_id);
				// add empty guessArea
				url = air_console.getProfilePicture(player_id, 120);
				$("#results-scrollable").append('<div class="single-result" id="player_' + player_id + '_result"><div class="position_display"></div><div class="darken_image"></div><img src="' + url + '"><div class="player_name">' + nickname + '</div><div class="player_score"></div>');

			}
		}

		function initialize_player_score(from, newScore, guessTime, guessTime, correct) {
			if (correct) {
				document.playerScores.push({ player: from, score: newScore, currentGuessTime: guessTime, totalGuessTime: guessTime, correct: correct, correctGuesses: 1 });
			} else {
				document.playerScores.push({ player: from, score: newScore, currentGuessTime: guessTime, totalGuessTime: guessTime, correct: correct, correctGuesses: 0 });
			}
		}

		function handle_guess(message, from) {

			// console.log("Player " + from + " made a guess!");

			// initialize the array that stores the general progress of the players
			if (!document.player) {
				document.player = [];
			}

			// initialize the array for the current device
			if (!document.player[from]) {
				// initialize array if not already present
				document.player[from] = [];
			}

			initiate_guessing_area(from);

			guessTime = (new Date().getTime() - document.startTime);
			negative_points = Math.round(0.01 * guessTime);

			actual_points = 300 - negative_points;
			if (actual_points < 0) actual_points = 0;
			guessTime = guessTime / 1000;

			correct = true;
			if (message[0].type !== "correctGuess") {
				actual_points = 0;
				correct = false;
			}

			newScore = actual_points;

			// try selecting current score
			playerScore = document.playerScores.filter(function (obj) {
				return obj.player === from;
			});

			let correctGuesses = 0;
			let totalGuessTime = 0;
			if (playerScore[0]) {
				newScore = playerScore[0].score + actual_points;
				playerScore[0].score = newScore;
				playerScore[0].currentGuessTime = guessTime;
				playerScore[0].correct = correct;
				playerScore[0].totalGuessTime += guessTime;
				totalGuessTime = playerScore[0].totalGuessTime;
				if (correct) {
					playerScore[0].correctGuesses++;
					correctGuesses = playerScore[0].correctGuesses;
				}
			} else {
				totalGuessTime = guessTime;
				if (correct) {
					correctGuesses = 1;
				}
				initialize_player_score(from, newScore, guessTime, guessTime, correct);
			}

			document.playerScores.sort(function (a, b) {
				if (a.score > b.score) {
					return -1;
				}
				if (a.score < b.score) {
					return 1;
				}
				return 0;
			});

			let position = 0;
			document.playerScores.forEach(function (score, index) {
				if (score.player === from) {
					position = index + 1;
				}
				score.position = index + 1;
			});

			$("#player_" + from + "_result .player_score").html(newScore);

			// send the score to the controller
			document.score = [];
			document.score.push({
				type: "score",
				score: { score: newScore, increase: actual_points, position: position }
			});
			// send the score to the specific client
			air_console.message(from, document.score);

			// console.log(document.playerScores);



			// console.log(document.playerScores);

			url = air_console.getProfilePicture(from, 120);
			resultArea = $("#player_" + from + "_result");
			resultArea.find("img").attr("src", url);

			position = 1;
			document.playerScores.forEach(function (element) {
				$("#player_" + element.player + "_result").find(".position_display").html(position + ".");

				if (position === 1) {
					$("#player_" + element.player + "_result").prependTo("#results-scrollable");
				} else {
					// insert after previous element
					$("#player_" + element.player + "_result").insertAfter("#player_" + previous_element.player + "_result");
				}
				previous_element = element;
				position++;
			});

			if (message[0].type === "correctGuess") {
				resultArea.find(".current_score").html(newScore);
				resultArea.find(".score_change").html("+ " + actual_points + " Points");
				resultArea.find(".current_time").html(guessTime + " seconds");
				resultArea.find(".darken_image").addClass("avatar_correct");
			} else {
				resultArea.find(".score_change").html("No Points");
				resultArea.find(".current_time").html(guessTime + " seconds");
				resultArea.find(".darken_image").addClass("avatar_wrong");
				actual_points = 0;
			}

			// increase the amount of finished players
			document.amount_of_finished_players++;

			DEBUG && console.log("handle_guess is calling check if all players have guessed");
			check_if_all_players_have_guessed();
			send_score();
		}

		function check_if_all_players_have_guessed() {
			// console.log("Currently Connected: " + air_console.getControllerDeviceIds().length);
			// console.log("Amount of finished players: " + document.amount_of_finished_players);
			// console.log("Amount of inactive clients: " + document.inactiveClients);
			// in theory this should play the next song when all connected devices have finished
			// since a controller can join after the round has started, this is probably a blocker we need to handle
			if (document.amount_of_finished_players === air_console.getControllerDeviceIds().length) {
				DEBUG && console.log("currently connected player amount: " + air_console.getControllerDeviceIds().length);
				DEBUG && console.log("all connected controllers have finished their guess");
				document.roundEndInitiated = true;
				round_end();

			}
			// check if the total is correct when considering inactive players
			else if (air_console.getControllerDeviceIds().length === document.amount_of_finished_players + document.inactiveClients) {
				DEBUG && console.log("all connected controllers have finished their guess, considering inactive controllers");
				document.roundEndInitiated = true;
				round_end();
			}
		}


	</script>

</head>

<body onload="init()">
	<div id="screen-wrapper">
		<div class="instruction logo">
			<span id="game_logo">MusicGuess</span>
			<span id="message"></span>
		</div>
		<div id="status-wrapper">
			<span id="status"></span>
		</div>
		<div id="current_song_service"></div>
		<div id="victory_screen"></div>
	</div>
	<div id="playlist-selector"></div>
	<div id="playlist-display"></div>
	<div id="roundCounter"></div>
	<div id="roundTime"></div>
	<div id="credits-container">
		<div id="credits">
			<span class="category">Developed by:</span>
			<span class="content">Christian Nyffenegger, <a
					onclick="air_console.openExternalUrl('https://twitter.com/freakpants')" target="_blank"
					href="https://twitter.com/freakpants">freakpants</a></span></br>
			<span class="category">Background video by:</span>
			<span class="content"><a target="_blank"
					href="https://pixabay.com/de/users/tommyvideo-3092371/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=5154">Tomislav
					Jakupec</a> / <a target="_blank"
					href="https://pixabay.com/de/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=5154">Pixabay</a></span></br>
			<span class="category">Music provided by:</span>
			<span class="content"><a target="_blank"
					href="https://developer.apple.com/library/archive/documentation/AudioVideo/Conceptual/iTuneSearchAPI/index.html">Itunes
					Search API Preview</a></span></br>
			<span class="category">Sound effects by:</span>
			<span class="content"><a target="_blank" href="https://www.zapsplat.com">Zapsplat</a></span></br>
			<span class="category">SVG Loaders by:</span>
			<span class="content"><a target="_blank" href="https://twitter.com/sherb">Sam Herbert</a> (<a
					target="_blank" href="https://github.com/SamHerbert/SVG-Loaders">Github</a>)</span></br>
		</div>
	</div>
	<div id="player-results">
		<div id="results-scrollable"></div>
	</div>
	<audio id="sound-effect-switch">
		<source src="sounds/switch.mp3" type="audio/mpeg">
	</audio>
	<audio id="sound-effect-clock">
		<source src="sounds/clock.mp3" type="audio/mpeg">
	</audio>
	<audio id="sound-effect-correct">
		<source src="sounds/correct.mp3" type="audio/mpeg">
	</audio>
	<audio id="sound-effect-wrong">
		<source src="sounds/error.mp3" type="audio/mpeg">
	</audio>
	<audio id="sound-effect-cheers">
		<source src="sounds/cheers.mp3" type="audio/mpeg">
	</audio>
	<audio id="sound-effect-click">
		<source src="sounds/click.mp3" type="audio/mpeg">
	</audio>
	<audio id="sound-effect-start">
		<source src="sounds/start.mp3" type="audio/mpeg">
	</audio>

	<audio id="player" autoplay>
		<source src="" type="audio/mpeg">
	</audio>
</body>