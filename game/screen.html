<head>
	<script type="text/javascript" src="https://www.airconsole.com/api/airconsole-1.7.0.js"></script>
	<link rel="stylesheet" href="screen.css">
	<link rel="stylesheet" href="shared.css">
	<link href="https://fonts.googleapis.com/css?family=Oswald|Roboto" rel="stylesheet">
	<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.0/jquery.min.js"></script>
	<link rel="stylesheet" href="https://ajax.googleapis.com/ajax/libs/jqueryui/1.12.1/themes/smoothness/jquery-ui.css">
	<script src="https://ajax.googleapis.com/ajax/libs/jqueryui/1.12.1/jquery-ui.min.js"></script>

	<script type="text/javascript">

		// whether or not to display all information
		const DEBUG = true;

		// scroll the result areas or not
		document.scroll_results = false;

		// variable to store the library in after an initial query
		var library;

		// relative to the sound effects
		document.musicVolume = 0.4;

		// store amount of correct full guesses
		document.amount_of_finished_players = 0;

		document.round = 0;
		// the setting that is used to count downwards. could potentially be modified by settings
		document.RoundTimeSetting = 30;
		document.RoundTime = document.RoundTimeSetting;
		document.defaultMaxRound = 20;
		document.maxRound = document.defaultMaxRound;

		// store current scores of players
		document.playerScores = [];

		document.inactiveClients = 0;

		document.game_in_progress = false;
		document.ad_showing = false;
		document.showing_credits = false;
		document.game_over_screen = false;
		document.playerFailed = false;

		document.low_performance = false;

		document.roundEndInitiated = false;

		document.selectedPlaylist;

		document.screen = "main-menu";
		document.menu = "new-game";
		document.default = true;
		document.setting = "round_amount";
		document.guessing_type = "guessing-both";

		document.hero = false;

		var specific_options_dialogue = "Choose the Setting you want to change or hit start to play with the current settings.";


		var playlists = [
			{
				name: "2000's",
				id: "11",
				description: "The best and the worst decade.",
				new: "0",
				hero: "1",
				amount_of_tracks: 317,
				album_art: [
					"album_art/270842179.jpg",
					"album_art/723351610.jpg",
					"album_art/293405771.jpg",
					"album_art/258056379.jpg"
				]
			},
			{
				name: "2010's",
				id: "26",
				description: "Music from 2010-2019",
				new: "0",
				hero: "0",
				amount_of_tracks: 196,
				album_art: [
					"album_art/389604528.jpg",
					"album_art/1209173681.jpg",
					"album_art/1444609107.jpg",
					"album_art/1440819356.jpg"
				]
			},
			{
				name: "70's",
				id: "9",
				description: "Rock'n Roll & Funk is born",
				new: "0",
				hero: "0",
				amount_of_tracks: 145,
				album_art: [
					"album_art/177408365.jpg",
					"album_art/1423191432.jpg",
					"album_art/208819125.jpg",
					"album_art/1423766994.jpg"
				]
			},
			{
				name: "80's",
				id: "10",
				description: "The age of MTV",
				new: "0",
				hero: "0",
				amount_of_tracks: 148,
				album_art: [
					"album_art/1329359005.jpg",
					"album_art/1489263727.jpg",
					"album_art/930166513.jpg",
					"album_art/1434144397.jpg"
				]
			},
			{
				name: "90's",
				id: "2",
				description: "Eurdance, Teen Pop, Hip Hop and Bravo Hits",
				new: "0",
				hero: "1",
				amount_of_tracks: 222,
				album_art: [
					"album_art/526521410.jpg",
					"album_art/171708494.jpg",
					"album_art/1288190404.jpg",
					"album_art/693198382.jpg"
				]
			},
			{
				name: "Ballads",
				id: "23",
				description: "",
				new: "0",
				hero: "1",
				amount_of_tracks: 114,
				album_art: [
					"album_art/2294739.jpg",
					"album_art/1440833098.jpg",
					"album_art/1235889139.jpg",
					"album_art/255843292.jpg"
				]
			},
			{
				name: "Christmas",
				id: "60",
				description: "",
				new: "0",
				hero: "0",
				amount_of_tracks: 117,
				album_art: [
					"album_art/1586667718.jpg",
					"album_art/1589967724.jpg",
					"album_art/726136064.jpg",
					"album_art/1488180530.jpg"
				]
			},
			{
				name: "Dance Music",
				id: "3",
				description: "Electronic Dance Music, mostly Trance.",
				new: "0",
				hero: "0",
				amount_of_tracks: 288,
				album_art: [
					"album_art/1445144506.jpg",
					"album_art/878950953.jpg",
					"album_art/569845385.jpg",
					"album_art/497230922.jpg"
				]
			},
			{
				name: "Deutschland",
				id: "7",
				description: "Songs in German or from Germany",
				new: "0",
				hero: "0",
				amount_of_tracks: 169,
				album_art: [
					"album_art/353494891.jpg",
					"album_art/723748769.jpg",
					"album_art/250216026.jpg",
					"album_art/513700005.jpg"
				]
			},
			{
				name: "Female Artists",
				id: "35",
				description: "Female artists & collaborations",
				new: "0",
				hero: "0",
				amount_of_tracks: 419,
				album_art: [
					"album_art/1494981947.jpg",
					"album_art/315025768.jpg",
					"album_art/387193895.jpg",
					"album_art/1243004209.jpg"
				]
			},
			{
				name: "freakpants' list of disaster",
				id: "0",
				description: "A list of music enjoyed by the creator of MusicGuess.",
				new: "0",
				hero: "0",
				amount_of_tracks: 649,
				album_art: [
					"album_art/481776149.jpg",
					"album_art/24141413.jpg",
					"album_art/279647264.jpg",
					"album_art/424593855.jpg"
				]
			},
			{
				name: "Global Hits 2021",
				id: "15",
				description: "The most successful global hits of 2021",
				new: "0",
				hero: "0",
				amount_of_tracks: 117,
				album_art: [
					"album_art/1565442393.jpg",
					"album_art/1563265502.jpg",
					"album_art/1576349937.jpg",
					"album_art/1576713766.jpg"
				]
			},
			{
				name: "Global Hits All Time",
				id: "43",
				description: "The most successful global hits of all Time, From 1950 to today",
				new: "0",
				hero: "1",
				amount_of_tracks: 429,
				album_art: [
					"album_art/1088530832.jpg",
					"album_art/930169184.jpg",
					"album_art/1308717177.jpg",
					"album_art/723390477.jpg"
				]
			},
			{
				name: "Hip-Hop/Rap",
				id: "21",
				description: "From Grandmaster Funk to Drake",
				new: "0",
				hero: "0",
				amount_of_tracks: 142,
				album_art: [
					"album_art/560148910.jpg",
					"album_art/1495267282.jpg",
					"album_art/1440819356.jpg",
					"album_art/1499567361.jpg"
				]
			},
			{
				name: "Latin",
				id: "22",
				description: "Songs in spanish, or from latin artists",
				new: "0",
				hero: "1",
				amount_of_tracks: 145,
				album_art: [
					"album_art/1597512989.jpg",
					"album_art/155658405.jpg",
					"album_art/1543991915.jpg",
					"album_art/1570323047.jpg"
				]
			},
			{
				name: "Pop Music",
				id: "1",
				description: "Music that a lot of people like",
				new: "0",
				hero: "1",
				amount_of_tracks: 685,
				album_art: [
					"album_art/1571338856.jpg",
					"album_art/724259722.jpg",
					"album_art/860304622.jpg",
					"album_art/389604528.jpg"
				]
			},
			{
				name: "Pop/Alternative Rock",
				id: "24",
				description: "Poprock and indie stuff",
				new: "0",
				hero: "0",
				amount_of_tracks: 214,
				album_art: [
					"album_art/1440713819.jpg",
					"album_art/6929336.jpg",
					"album_art/1320780883.jpg",
					"album_art/3446432.jpg"
				]
			},
			{
				name: "Rock & Metal",
				id: "5",
				description: "Mostly of the softer persuasion though",
				new: "0",
				hero: "0",
				amount_of_tracks: 100,
				album_art: [
					"album_art/418710473.jpg",
					"album_art/3445786.jpg",
					"album_art/214475427.jpg",
					"album_art/190655957.jpg"
				]
			},
			{
				name: "Spain's Most Wanted December 2021",
				id: "61",
				description: "Songs that People in Spain shazamed the most",
				new: "0",
				hero: "1",
				amount_of_tracks: 189,
				album_art: [
					"album_art/1601594741.jpg",
					"album_art/1592109188.jpg",
					"album_art/1444051386.jpg",
					"album_art/1597422749.jpg"
				]
			},
			{
				name: "Swiss",
				id: "12",
				description: "Songs from Switzerland. mostly in Swiss German",
				new: "0",
				hero: "0",
				amount_of_tracks: 105,
				album_art: [
					"album_art/1122691144.jpg",
					"album_art/414917353.jpg",
					"album_art/1530784862.jpg",
					"album_art/1458470605.jpg"
				]
			},
			{
				name: "Today's Top 50",
				id: "63",
				description: "The 50 most popular tracks today!",
				new: "1",
				hero: "1",
				amount_of_tracks: 50,
				album_art: [
					"album_art/1592844016.jpg",
					"album_art/1604376321.jpg",
					"album_art/1590035691.jpg",
					"album_art/1585274078.jpg"
				]
			},
			{
				name: "Trance",
				id: "4",
				description: "Beats & Vocals",
				new: "0",
				hero: "0",
				amount_of_tracks: 103,
				album_art: [
					"album_art/453207238.jpg",
					"album_art/285800013.jpg",
					"album_art/441665313.jpg",
					"album_art/692877437.jpg"
				]
			},
			{
				name: "UK",
				id: "42",
				description: "Artists from the Kingdom",
				new: "0",
				hero: "0",
				amount_of_tracks: 259,
				album_art: [
					"album_art/991509751.jpg",
					"album_art/415628679.jpg",
					"album_art/1096967559.jpg",
					"album_art/1122775993.jpg"
				]
			},
			{
				name: "US Hits 2020",
				id: "30",
				description: "US Hits of last year",
				new: "0",
				hero: "1",
				amount_of_tracks: 100,
				album_art: [
					"album_art/1490463311.jpg",
					"album_art/1551178998.jpg",
					"album_art/1495267282.jpg",
					"album_art/1497390717.jpg"
				]
			}
		];
		var air_console;

		$(document).ready(function () {
			loop1();
			document.getElementById("player").addEventListener('error', function failed(e) {
				// audio playback failed - show a message saying why
				// to get the source of the audio element use $(this).src
				if (e.target.error !== undefined) {
					switch (e.target.error.code) {
						case e.target.error.MEDIA_ERR_SRC_NOT_SUPPORTED:
							DEBUG && console.log('The video audio not be loaded, either because the server or network failed or because the format is not supported.');
						case e.target.error.MEDIA_ERR_ABORTED:
							DEBUG && console.log('You aborted the video playback.');
						case e.target.error.MEDIA_ERR_NETWORK:
							DEBUG && console.log('A network error caused the audio download to fail.');
						case e.target.error.MEDIA_ERR_DECODE:
							DEBUG && console.log('The audio playback was aborted due to a corruption problem or because the video used features your browser did not support.');
						default:
							DEBUG && console.log('An unknown error occurred.');
							document.playerFailed = true;
							break;
					}
				}
			}, true);
		});

		function loop1() {
			$("#ticker1").animate({ "margin-left": "-100vw" }, 15000, () => {
				$("#ticker-wrapper").prepend($("#ticker2"));
				$("#ticker1").css("margin-left", "unset");
				$("#ticker1").css("margin-right", "200vw");
				$("#ticker2").css("margin-right", "unset");
				loop2();
			});
		}

		function loop2() {
			$("#ticker2").animate({ "margin-left": "-100vw" }, 7500, () => {
				$("#ticker-wrapper").prepend($("#ticker1"));
				$("#ticker2").css("margin-left", "unset");
				$("#ticker2").css("margin-right", "200vw");
				$("#ticker1").css("margin-right", "unset");
				loop3();
			});
		}

		function loop3() {
			$("#ticker1").animate({ "margin-left": "-100vw" }, 7500, () => {
				$("#ticker-wrapper").prepend($("#ticker2"));
				$("#ticker1").css("margin-left", "unset");
				$("#ticker1").css("margin-right", "200vw");
				$("#ticker2").css("margin-right", "unset");
				loop2();
			});
		}

		function check_for_freakpants() {
			// get all controller ids
			var controller_ids = air_console.getControllerDeviceIds();
			const freakpants_uid = "89a1f2d330e4349b867e6341c6fcc892";
			var result = false;
			// loop each id with foreach
			controller_ids.forEach((controller_id) => {
				DEBUG && console.log("controller uid: " + air_console.getUID(controller_id));
				DEBUG && console.log("comparing with:" + freakpants_uid);
				DEBUG && console.log("result: " + (air_console.getUID(controller_id) === freakpants_uid));
				if (air_console.getUID(controller_id) === freakpants_uid) {
					result = true;
				}
			});
			return result;
		}


		function set_guessing_type_message() {
			switch (document.guessing_type) {
				case "guessing-both":
					$("#message").html("Guess the artist or title that is currently playing!");
					break;
				case "guessing-artist":
					$("#message").html("Guess the artist that is currently playing!");
					break;
				case "guessing-title":
					$("#message").html("Guess the title that is currently playing!");
					break;
			}
		}

		function display_loading() {
			display_loading_object = [];
			display_loading_object.push({ type: "display_loading" });
			air_console.broadcast(display_loading_object);
		}

		function hide_loading() {
			hide_loading_object = [];
			hide_loading_object.push({ type: "hide_loading" });
			air_console.broadcast(hide_loading_object);
		}

		function init() {
			air_console = new AirConsole();


			air_console.onPremium = function (device_id) {
				DEBUG && console.log("Hero User connected!");
				document.hero = true;
				check_if_playlist_needs_hero();
			}

			air_console.onReady = function (){
				controller_boundary_option("first");
			}

			// watch for new controllers connecting
			air_console.onConnect = function (device_id) {
				// let the new controller know how many rounds are currently selected
				update_selected_rounds_on_controllers();
				// also inform the new controller of the current limit for the selected playlist
				update_max_rounds_on_controllers();

				// update_controllers_about_game_status();

				// we actually need to do this on game start as well, for every client, since we delete the areas after the game
				initiate_guessing_area(device_id);


				/* prepare messages for clients */
				show_menu = [];
				show_menu.push({
					type: "show_menu"
				});
				hide_menu = [];
				hide_menu.push({
					type: "hide_menu"
				});
				inactive = [];
				inactive.push({
					type: "inactive"
				});
				show_back_from_credits = [];
				show_back_from_credits.push({
					type: "show_back_from_credits"
				});
				show_back_to_main = [];
				show_back_to_main.push({
					type: "show_back_to_main"
				});

				// check if there is currently a round in progress
				if (document.round > 0 && !document.roundEndInitiated && !document.game_over_screen) {
					DEBUG && console.log("we a currently in a game");
					// let the new client know to display the please wait message (instead of waiting for master controller)
					air_console.message(device_id, inactive);
					// store the fact that we have an inactive client in this round
					document.inactiveClients += 1;
				} else if (document.game_over_screen) {
					DEBUG && console.log("we are currently showing the game over screen");
					// if the client is master, direct him to show the back to main
					if (air_console.getMasterControllerDeviceId() !== undefined && air_console.getMasterControllerDeviceId() === device_id) {
						air_console.message(device_id, show_back_to_main);
					} else {
						// otherwise, just show the regular waiting for start
						air_console.message(device_id, hide_menu);
					}
				} else if (document.showing_credits) {
					DEBUG && console.log("we are currently showing credits");
					// if we are currently showing credits, let the client know what to display
					// if the client is master, direct him to show the back from credits
					if (air_console.getMasterControllerDeviceId() !== undefined && air_console.getMasterControllerDeviceId() === device_id) {
						air_console.message(device_id, show_back_from_credits);
					} else {
						// otherwise, just show the regular waiting for start
						air_console.message(device_id, hide_menu);
					}
				} else {
					DEBUG && console.log("There is no round in progress, and we are not showing credits");
					// if there is no round in progress, check if the connected device is the master
					if (air_console.getMasterControllerDeviceId() !== undefined && air_console.getMasterControllerDeviceId() === device_id) {
						DEBUG && console.log("device " + device_id + " is the master");
						// let the new client know to display the menu)
						air_console.message(device_id, show_menu);
						// also let all other clients know NOT to display the menu anymore
						air_console.getControllerDeviceIds().forEach(function (id) {
							if (id === device_id) return;
							air_console.message(id, hide_menu);
						});
					} else {
						DEBUG && console.log("device " + device_id + " is not a master");
						air_console.message(device_id, hide_menu);
					}

				}

				if (check_for_freakpants()) {
					$("#connect-spotify-button").css("display", "flex");
				}
			};

			air_console.onDisconnect = function (device_id) {
				// update_controllers_about_game_status();
				// check if there is currently a round in progress
				if (document.round > 0 && !document.roundEndInitiated && !document.game_over_screen) {
					// do nothing?
				} else if (document.game_over_screen) {
					// let the new master know to display the back to main
					if (air_console.getMasterControllerDeviceId() !== undefined) {
						DEBUG && console.log("informing new master to show the back to main button");
						message = [];
						message.push({
							type: "show_back_to_main"
						});
						air_console.message(air_console.getMasterControllerDeviceId(), message);
					}
				} else if (document.showing_credits) {
					// let the new master know to display the back from credits
					if (air_console.getMasterControllerDeviceId() !== undefined) {
						DEBUG && console.log("informing new master to show the back to credits button");
						message = [];
						message.push({
							type: "show_back_from_credits"
						});
						air_console.message(air_console.getMasterControllerDeviceId(), message);
					}
				} else {
					// let the new master know to display the menu
					if (air_console.getMasterControllerDeviceId() !== undefined) {
						message = [];
						message.push({
							type: "show_menu"
						});
						air_console.message(air_console.getMasterControllerDeviceId(), message);
					}
				}
			}

			// Listen for messages from other devices
			air_console.onMessage = function (from, message) {
				// handle message
				var type = message[0].type;
				DEBUG && console.log('handling ' + type + ' message on screen.');

				switch (type) {
					case 'back':
						// determine what screen we are on
						switch (document.screen) {
							case "spotify":
								// go back to menu
								display_loading();
								$("#game_logo").animate({ fontSize: "115px" }, 1500);
								$("#spotify").animate({ opacity: 0 }, 1500);
								sleep(1500).then(() => {
									$("#main-menu").animate({ opacity: 1 }, 1500);
									sleep(1500).then(() => {
										hide_loading();
									});
								});
								document.screen = "main-menu";
								break;
							case "updates":
								// go back to menu
								display_loading();
								$("#game_logo").animate({ fontSize: "115px" }, 1500);
								$("#updates").animate({ opacity: 0 }, 1500);
								sleep(1500).then(() => {
									$("#main-menu").animate({ opacity: 1 }, 1500);
									sleep(1500).then(() => {
										hide_loading();
									});
								});
								document.screen = "main-menu";
								break;

							case "guessing-type-selector":
								$("#guessing-type-selector").hide();
								$("#option-selector").show();
								$("#specific-options .dialogue").html(specific_options_dialogue);
								document.screen = "specific-options";
								break;
							case "round-amount-selector":
								// inform controller to hide increase/decrease buttons
								hide_round_change_buttons = [];
								hide_round_change_buttons.push({ type: "hide_round_change_buttons" });
								air_console.broadcast(hide_round_change_buttons);

								$("#round-amount-selector").hide();
								$("#option-selector").show();
								$("#specific-options .dialogue").html(specific_options_dialogue);
								document.screen = "specific-options";
								break;
							case "specific-options":

								// go back to default selection
								document.screen = "default-options";
								$("#specific-options").hide();
								$("#default-options").css("display", "flex");
								break;
							case "default-options":
								// go back to playlist selection
								document.screen = "playlist-selection";
								$("#default-options").hide();
								$("#playlist-display").hide();
								$("#roundCounter").hide();
								$("#playlist-selector").css("display", "flex");
								break;
							case "playlist-selection":
								// go back to menu
								$("#game_logo").animate({ fontSize: "115px" }, 1500);
								document.screen = "main-menu";
								$("#playlist-selector").hide();
								$("#main-menu").show();
								break;
							case "credits":
								document.screen = "main-menu";
								display_loading();
								$("#credits").animate({ opacity: 0 }, 1500);
								$("#game_logo").animate({ fontSize: "115px" }, 1500);
								sleep(1500).then(() => {
									document.showing_credits = false;
									$("#credits").hide();
									$("#credits-container").hide();

									$("#main-menu").animate({ opacity: 1 }, 1500);
									sleep(1500).then(() => {
										hide_loading();
									});
								});
								break;
						}
						break;
					case 'confirm':
						controller_boundary_option(false);
						// determine what screen we are on
						switch (document.screen) {
							case "spotify":
								var masterId = air_console.getMasterControllerDeviceId();
								var masterUID = air_console.getUID(masterId);
								var url = "https://8080-d4794a7b-7ff0-4db9-8e67-33f69cf31cb2.cs-europe-west1-onse.cloudshell.dev/?authuser=0&uid=" + masterUID;
								air_console.openExternalUrl(url);
								break;
							case "splash":
								DEBUG && console.log("handling confirm button on splash screen");
								$("#splash-screen").animate({ opacity: 0 }, 1500);

								// inform master controller to display loading
								display_loading();

								sleep(1500).then(() => {
									$("#main-menu").animate({ opacity: 1 }, 1500);
									sleep(1500).then(() => {
										// inform master controller to hide loading
										hide_loading();
									});
								});
								document.screen = "main-menu";
								break;
							case "main-menu":
								DEBUG && console.log("handling confirm button in main menu");
								switch (document.menu) {
									case "new-game":
										DEBUG && console.log("showing playlist selector for new game");
										display_loading();
										$("#main-menu").hide();
										$("#playlist-selector .dialogue").css("display", "flex");
										$("#playlist-selector .dialogue-wrapper").css("display", "flex");
										$("#game_logo").animate({ fontSize: "80px" }, 1500);
										sleep(1500).then(() => {
											$("#playlist-selector").css("display", "flex");
											hide_loading();
										});
										document.screen = "playlist-selection";
										check_if_playlist_needs_hero();
										break;
									case "credits":
										DEBUG && console.log("showing credits");
										display_loading();
										$("#main-menu").animate({ opacity: 0 }, 1500);
										$("#game_logo").animate({ fontSize: "80px" }, 1500);
										$("#playlist-selector").hide("fade", {}, 1500);
										$("#credits-container").show();
										$("#credits").css({ display: "flex" });
										sleep(1500).then(() => {
											document.showing_credits = true;
											$("#credits").animate({ opacity: 1 }, 1500);
											sleep(1500).then(() => {
												if (air_console.getMasterControllerDeviceId() !== undefined) {
													air_console.message(air_console.getMasterControllerDeviceId(), show_back_from_credits);
												}
											});
										});
										document.screen = "credits";
										break;
									case "updates":
										DEBUG && console.log("displaying latest updates");
										display_loading();
										$("#main-menu").animate({ opacity: 0 }, 1500);
										$("#game_logo").animate({ fontSize: "80px" }, 1500);
										$("#updates").css("display", "flex");
										$("#updates").animate({ opacity: 0.9 }, 1500);
										sleep(1500).then(() => {
											hide_loading();
										});
										document.screen = "updates";
										break;
									case "spotify":
										DEBUG && console.log("spotify menu");
										// 
										var masterControllerId = air_console.getMasterControllerDeviceId();
										var masterUser = air_console.getNickname(masterControllerId);
										var uid = air_console.getUID(masterControllerId);
										console.log(masterUser);
										console.log(uid);
										$("#master-user").html("freakpants");

										display_loading();
										$("#main-menu").animate({ opacity: 0 }, 1500);
										$("#game_logo").animate({ fontSize: "80px" }, 1500);
										$("#spotify").css("display", "flex");
										$("#spotify").animate({ opacity: 0.9 }, 1500);
										sleep(1500).then(() => {
											hide_loading();
										});
										document.screen = "spotify";
										break;
								}
								break;
							case "guessing-type-selector":
								active_option = $("#guessing-type-selector .active");
								document.guessing_type = $(active_option).attr("id");
								$("#guessing-type-selector").hide();
								$("#specific-options .dialogue").html(specific_options_dialogue);
								guessingType = $(active_option).html();
								document.screen = "specific-options";
								$("#guessing_type").html(guessingType);
								$("#option-selector").show();
								break;
							case "round-amount-selector":
								DEBUG && console.log("saving selected round amount and going back to specific options");

								active_option = $("#round-amount-selector .active");
								if ($(active_option).html() === "Custom Amount") {
									// just go back, since we have already set document.maxRound
								} else {
									document.maxRound = parseInt($(active_option).html());
								}
								$("#round-amount-selector").hide();
								$("#specific-options .dialogue").html(specific_options_dialogue);
								$("#option-selector").show();
								document.screen = "specific-options";

								// inform controller to hide increase/decrease buttons
								hide_round_change_buttons = [];
								hide_round_change_buttons.push({ type: "hide_round_change_buttons" });
								air_console.broadcast(hide_round_change_buttons);
								break;
							case "specific-options":
								DEBUG && console.log("handling confirm button on specific options");

								switch (document.setting) {
									case "round_amount":
										controller_boundary_option("first");
										document.screen = "round-amount-selector";
										$("#option-selector").hide();

										let max_rounds = "Error: No playlist is selected. Please restart the game.";
										if (playlists[document.selectedPlaylist] !== undefined) {
											max_rounds = playlists[document.selectedPlaylist]['amount_of_tracks'];
										}

										$("#specific-options .dialogue").html("How many rounds do you want to play? (Max " + max_rounds + ")");
										$("#round-amount-selector").css("display", "flex");

										// reset the options to the first setting
										$("#round-amount-selector li").removeClass("active");
										const firstOption = $("#round-amount-selector li").first();
										$(firstOption).addClass("active");
										$("#roundCounter").html($(firstOption).html() + " Rounds");

										break;
									case "guessing_type":
										document.screen = "guessing-type-selector";
										$("#option-selector").hide();
										$("#specific-options .dialogue").html("Select whether each round players have to guess either artist or title randomly, or only one of each.");
										$("#guessing-type-selector").css("display", "flex");
										break;
									case "start":
										DEBUG && console.log("starting the game after specific options were chosen");
										$(".dialogue").hide();
										$("#specific-options").hide();
										// start the game
										document.getElementById("sound-effect-start").play();
										document.screen = "playing";
										start();
										break;
								}

								break;
							case "default-options":
								controller_boundary_option("first");
								DEBUG && console.log("handling confirm button on default options");
								$("#default-options").hide();
								if (document.default) {
									// start the game
									DEBUG && console.log("starting the game with default options");
									document.getElementById("sound-effect-start").play();
									document.screen = "playing";
									start();
								} else {
									// go to specific options
									DEBUG && console.log("showing specific options");
									document.screen = "specific-options";
									$("#specific-options .dialogue").html(specific_options_dialogue);
									$("#specific-options .dialogue").css("display", "flex");
									$("#specific-options").css("display", "flex");
								}
								break;
							case "playlist-selection":

								controller_boundary_option("first");

								DEBUG && console.log("going to default options");
								// go to default option prompt
								document.screen = "default-options";
								$("#playlist-selector").hide();
								$("#default-options").css("display", "flex");
								$("#default-options .dialogue").css("display", "flex");

								// display selected playlist
								$("#playlist-display").html("Playlist:</br>" + playlists[document.selectedPlaylist].name);
								$("#playlist-display").css({ display: "flex" });

								// display round amount to play
								$("#roundCounter").html(document.maxRound + " Rounds");
								$("#roundCounter").css({ display: "flex" });

								break;
						}
						break;
					case 'correctGuess':
						// play the correct guess sound
						document.getElementById("sound-effect-correct").play();
						// deal with the score changes etc
						if (!document.cancelled) {
							handle_guess(message, from);
						}
						break;
					case 'wrongGuess':
						// play the wrong guess sound
						document.getElementById("sound-effect-wrong").play();
						// deal with the score changes etc
						if (!document.cancelled) {
							handle_guess(message, from);
						}
						break;
					case 'next':
						// play switch sound effect
						document.getElementById("sound-effect-switch").play();
						// determine where we are
						switch (document.screen) {
							case "guessing-type-selector":
								active_option = $("#guessing-type-selector .active");
								if ($(active_option).is(':last-child')) {
									next_option = $("#guessing-type-selector li").first();
								} else {
									next_option = $(active_option).next();
								}
								$(active_option).removeClass("active");
								$(next_option).addClass("active");
								break;
							case "round-amount-selector":
								active_option = $("#round-amount-selector .active");
								if ($(active_option).is(':last-child')) {
									break;
									//next_option = $("#round-amount-selector li").first();
								} else {
									next_option = $(active_option).next();
								}

								if ($(next_option).is(':last-child')) {
									controller_boundary_option("last");
								} else {
									controller_boundary_option(false);
								}

								$(active_option).removeClass("active");
								$(next_option).addClass("active");
								if ($(next_option).html() === "Custom Amount") {
									document.maxRound = document.defaultMaxRound;
									$("#roundCounter").html(document.defaultMaxRound + " Rounds");
									// inform controller to display increase/decrease buttons
									show_round_change_buttons = [];
									show_round_change_buttons.push({ type: "show_round_change_buttons" });
									air_console.broadcast(show_round_change_buttons);
								} else {
									// inform controller to hide increase/decrease buttons
									hide_round_change_buttons = [];
									hide_round_change_buttons.push({ type: "hide_round_change_buttons" });
									air_console.broadcast(hide_round_change_buttons);
									$("#roundCounter").html($(next_option).html() + " Rounds");
								}

								break;
							case "specific-options":
								switch (document.setting) {
									case "round_amount":
										document.setting = "guessing_type";
										$("#round_amount_option").removeClass("active");
										$("#guessing_type").addClass("active");
										controller_boundary_option(false);
										break;
									case "guessing_type":
										document.setting = "start";
										$("#guessing_type").removeClass("active");
										$("#specific-start").addClass("active");
										controller_boundary_option("last");
										break;
									case "start":
										/* 
										document.setting = "round_amount";
										$("#specific-start").removeClass("active");
										$("#round_amount_option").addClass("active");
										controller_boundary_option("last");
										break; */
								}

								break;
							case "default-options":
								if (document.default) {
									document.default = false;
									$("#default-no").addClass("active");
									$("#default-yes").removeClass("active");
									controller_boundary_option("last");
								} else {
									/* controller_boundary_option("first");
									document.default = true;
									$("#default-yes").addClass("active");
									$("#default-no").removeClass("active"); */
								}
								break;
							case "playlist-selection":
								switch_playlist('next');
								break;
							case "main-menu":
								switch (document.menu) {
									case "new-game":
										document.menu = "credits";
										$("#new-game-button").removeClass("active");
										$("#credits-button").addClass("active");
										controller_boundary_option(false);
										break;
									case "credits":
										document.menu = "updates";
										$("#credits-button").removeClass("active");
										$("#updates-button").addClass("active");
										if(!check_for_freakpants()){
											controller_boundary_option("last");
										} else {
											controller_boundary_option(false);
										}
										break;
									case "updates":
										if (check_for_freakpants()) {
											controller_boundary_option("last");
											document.menu = "spotify";
											$("#updates-button").removeClass("active");
											$("#connect-spotify-button").addClass("active");
										} else {
											// dont do anything at the last spot
											// document.menu = "new-game";
											// $("#updates-button").removeClass("active");
											// $("#new-game-button").addClass("active");
										}

										break;
									case "spotify":
										/* document.menu = "new-game";
										$("#connect-spotify-button").removeClass("active");
										$("#new-game-button").addClass("active"); */
								}
								break;
						}
						break;
					case 'previous':
						// play switch sound effect
						document.getElementById("sound-effect-switch").play();
						// determine where we are
						switch (document.screen) {
							case "guessing-type-selector":
								active_option = $("#guessing-type-selector .active");
								if ($(active_option).is(':first-child')) {
									previous_option = $("#guessing-type-selector li").last();
								} else {
									previous_option = $(active_option).prev();
								}

								$(active_option).removeClass("active");
								$(previous_option).addClass("active");

								break;
							case "round-amount-selector":
								active_option = $("#round-amount-selector .active");
								if ($(active_option).is(':first-child')) {
									break;
									// previous_option = $("#round-amount-selector li").last();
								} else {
									previous_option = $(active_option).prev();
								}

								if ($(previous_option).is(':first-child')) {
									controller_boundary_option("first");
								} else {
									controller_boundary_option(false);
								}

								$(active_option).removeClass("active");
								$(previous_option).addClass("active");
								if ($(previous_option).html() === "Custom Amount") {
									document.maxRound = document.defaultMaxRound;
									$("#roundCounter").html(document.defaultMaxRound + " Rounds");
									// inform controller to display increase/decrease buttons
									show_round_change_buttons = [];
									show_round_change_buttons.push({ type: "show_round_change_buttons" });
									air_console.broadcast(show_round_change_buttons);
								} else {
									// inform controller to hide increase/decrease buttons
									hide_round_change_buttons = [];
									hide_round_change_buttons.push({ type: "hide_round_change_buttons" });
									air_console.broadcast(hide_round_change_buttons);
									$("#roundCounter").html($(previous_option).html() + " Rounds");
								}

								break;
							case "specific-options":
								switch (document.setting) {
									case "round_amount":
										/* document.setting = "start";
										$("#round_amount_option").removeClass("active");
										$("#specific-start").addClass("active");
										break; */
									case "guessing_type":
										document.setting = "round_amount";
										$("#guessing_type").removeClass("active");
										$("#round_amount_option").addClass("active");
										controller_boundary_option("first");
										break;
									case "start":
										document.setting = "guessing_type";
										$("#specific-start").removeClass("active");
										$("#guessing_type").addClass("active");
										controller_boundary_option(false);
										break;
								}
								break;
							case "default-options":
								if (document.default) {
									/* document.default = false;
									$("#default-no").addClass("active");
									$("#default-yes").removeClass("active"); */
								} else {
									document.default = true;
									$("#default-yes").addClass("active");
									$("#default-no").removeClass("active");
									controller_boundary_option("first");
								}
							case "playlist-selection":
								switch_playlist('previous');
								break;
							case "main-menu":
								switch (document.menu) {
									case "new-game":
										// dont do anything at the first selection
										/* 
										if (check_for_freakpants()) {
											document.menu = "spotify";
											$("#new-game-button").removeClass("active");
											$("#connect-spotify-button").addClass("active");
										} else {
											document.menu = "updates";
											$("#new-game-button").removeClass("active");
											$("#updates-button").addClass("active");
										} */

										break;
									case "credits":
										document.menu = "new-game";
										$("#credits-button").removeClass("active");
										$("#new-game-button").addClass("active");
										controller_boundary_option("first");
										break;
									case "updates":
										document.menu = "credits";
										$("#updates-button").removeClass("active");
										$("#credits-button").addClass("active");
										controller_boundary_option(false);
										break;
									case "spotify":
										document.menu = "updates";
										$("#connect-spotify-button").removeClass("active");
										$("#updates-button").addClass("active");
										break;

								}
								break;
						}
						break;
					case 'decrease_rounds':
						document.getElementById("sound-effect-click").play();
						document.maxRound = document.maxRound - 1;
						$("#roundCounter").html(document.maxRound + " Rounds");
						update_selected_rounds_on_controllers();
						break;
					case 'increase_rounds':
						// check if the maximum amount of rounds for this playlist has been reached or not
						if (playlists[document.selectedPlaylist] !== undefined &&
							((document.maxRound) == playlists[document.selectedPlaylist]['amount_of_tracks'])) {
							// dont increase
						} else {
							document.getElementById("sound-effect-click").play();
							document.maxRound = document.maxRound + 1;
							$("#roundCounter").html(document.maxRound + " Rounds");
							update_selected_rounds_on_controllers();
						}
						break;
					case 'cancel':
						controller_boundary_option(false);
						$("#message").html("");
						$("#message").hide();
						$("#roundCounter").hide();
						$("#playlist-display").hide();
						// inform other controllers
						hide_menu = [];
						hide_menu.push({
							type: "hide_menu"
						});

						// in case some controllers were still waiting
						sleep(2000).then(() => {
							air_console.broadcast(hide_menu);
						});

						document.cancelled = true;
						document.roundEndInitiated = true;

						document.amount_of_finished_players = 0;

						document.game_in_progress = false;
						document.game_over_screen = false;

						player = document.getElementById("player");
						player.volume = 0;

						$("#roundTime").hide();
						$("#current_song_service").hide();
						$("#playanimation").hide();

						// reset the results area and the round status
						$("#results-scrollable").html("");
						$("#status").hide();
						$("#status").html("");

						$("#victory_screen").hide();
						$("#victory_screen").html("");

						$("#game_logo").show("fade", {}, 1500);
						// $("#playlist-selector").show("fade", {}, 1500);
						$("#main-menu").show();
						document.screen = "main-menu";

						break;
					case 'back_to_main':
						document.screen = "main-menu";
						$("#message").html("");
						// $("#message").hide("fade", {}, 1500);

						document.game_in_progress = false;
						document.game_over_screen = false;

						// reset the results area and the round status
						$("#results-scrollable").html("");
						$("#status").hide();
						$("#status").html("");

						$("#victory_screen").hide();
						$("#victory_screen").html("");

						/* back_to_main = [];
						back_to_main.push({ type: "back_to_main" }); */

						$("#game_logo").css("fontSize", "115px");
						$("#game_logo").show("fade", {}, 1500);

						$("#main-menu").show();
						// $("#playlist-selector").show("fade", {}, 1500);

						// air_console.broadcast(back_to_main);

						break;
				}
			};

			air_console.onAdShow = function () {
				DEBUG && console.log("ad has started showing");
				document.ad_showing = true;
			};

			air_console.onAdComplete = function (ad_was_shown) {
				DEBUG && console.log("onAdComplete is triggered");
				document.ad_showing = false;
				document.roundEndInitiated = true;
				next_round();
			};

			// get the playlists info
			// $.ajax({ method: "GET", url: "playlists/playlist_info.json", data: {}, dataType: "json" })
			// .done(function (msg) {
			// playlists = msg;
			// display info for the first playlist

			html = '';
			counter = 0;
			middle_id = Math.floor(playlists.length / 2);

			/* playlists.forEach(function (playlist) {
				DEBUG && console.log("loading playlist");
				DEBUG && console.log(playlist);
				if (counter === middle_id) {
					// defaults to popular stuff
					document.selectedPlaylist = counter;
					update_max_rounds_on_controllers();
					html += '<div id="playlist_' + counter + '" data-html-id="' + counter + '" class="album_art active">';
				} else {
					html += '<div id="playlist_' + counter + '" data-html-id="' + counter + '" class="album_art">';
				}

				if (air_console !== undefined) {
					air_console.devices.forEach(device_object => {
						if (device_object !== undefined && device_object !== null && device_object.client !== null && device.client.low_performance) {
							document.low_performance = true;
						}
					});
				}

				// dont even add the images on the gamehub app
				if (!document.low_performance) {
					playlist.album_art.forEach(function (element) {
						html = html + '<img src="' + element + '" />';
					});
					$("#screen-wrapper").append('<img id="playanimation" src="audio.svg" />');
					$("body").append('<video playsinline autoplay muted loop id="bgvid"><source src="videos/disco_loop.mp4" type="video/mp4"></video>');
					if (playlist.new === "1") {
						html = html + '<span class="new-sticker">NEW!</span>';
					}
				}

				html += '<div class="playlist-text"><b>' + playlist.name + '</b>';
				html += playlist.amount_of_tracks + ' Tracks</br>';
				html += '<span class="playlist-description">' + playlist.description + '</span>';
				html += '</div>';
				html += '</div>';
				counter++;
			}); */

			document.selectedPlaylist = 1;
			update_max_rounds_on_controllers();

			DEBUG && console.log(playlists);

			if (air_console !== undefined) {
				air_console.devices.forEach(device_object => {
					if (device_object !== undefined && device_object !== null && device_object.client !== null && device.client.low_performance) {
						document.low_performance = true;
					}
				});
			}

			var add_to_storage_only = false;
			document.playlist_storage = [];
			var playlist_html;

			$("#screen-wrapper").append('<img id="playanimation" src="audio.svg" />');
			$("body").append('<video playsinline autoplay muted loop id="bgvid"><source src="videos/disco_loop.mp4" type="video/mp4"></video>');

			playlists.every(function (playlist) {

				if (counter > 2) {
					add_to_storage_only = true;
				}
				DEBUG && console.log("loading playlist");
				DEBUG && console.log(playlist);
				DEBUG && console.log(playlist.name);
				if (!add_to_storage_only) {
					switch (counter) {
						case 0:
							html += '<div id="playlist_' + counter + '" data-html-id="' + counter + '" class="album_art previous">';
							break;
						case 1:
							html += '<div id="playlist_' + counter + '" data-html-id="' + counter + '" class="album_art active">';
							break;
						case 2:
							html += '<div id="playlist_' + counter + '" data-html-id="' + counter + '" class="album_art next">';
							break;
					}
				}

				playlist_html = '';
				// dont even add the images on the gamehub app
				// document.low_performance = true;
				if (!document.low_performance) {
					playlist.album_art.forEach(function (element) {
						if (!add_to_storage_only) {
							html = html + '<img src="' + element + '" />';
						}
						playlist_html += '<img src="' + element + '" />';
					});
					if (playlist.new === "1") {
						if (!add_to_storage_only) {
							html = html + '<span class="new-sticker">NEW!</span>';
						}
						playlist_html += '<span class="new-sticker">NEW!</span>';
					}
					if (playlist.hero === "1") {
						if (!add_to_storage_only) {
							html = html + '<span class="hero-sticker"><img id="hero-image" src="images/hero.gif" /></span>';
						}
						playlist_html += '<span class="hero-sticker"><img id="hero-image" src="images/hero.gif" /></span>';
					}
				}

				if (!add_to_storage_only) {
					html += '<div class="playlist-text-wrapper"><div class="playlist-text">' + playlist.name;
				}
				playlist_html += '<div class="playlist-text-wrapper"><div class="playlist-text">' + playlist.name;
				if (counter === 1) {
					details = '<div id="details-wrapper"><div id="playlist-details"><span class="playlist-track-count">' + playlist.amount_of_tracks + ' Tracks</span>';
					details += '<span class="playlist-description">' + playlist.description + '</span></div></div>';
				}
				if (!add_to_storage_only) {
					html += '</div></div>';
					html += '<div id="disc-hole-wrapper" ><div id="disc-hole"></div></div>';
					html += '</div>';
				}

				playlist_html += '</div></div>';
				playlist_html += '<div id="disc-hole-wrapper" ><div id="disc-hole"></div></div>';
				playlist_html += '</div>';

				document.playlist_storage[counter] = playlist_html;

				counter++;
				return true;
			});

			DEBUG && console.log(document.playlist_storage);

			$("#playlist-selector").append(html);
			$("#playlist-selector").append(details);
			// $("#playlist-selector").css("display", "flex");

			// go to a specific playlist (workaround until rewrite)
			// switch_playlist("next");
			switch_playlist("previous");
			switch_playlist("previous");
			switch_playlist("previous");
			switch_playlist("previous");
			switch_playlist("previous");

			//	});
		}



		function calculateRoundTime() {

			// calculate the difference between the start of the round and now
			currentTime = new Date().getTime();
			timePassed = Math.floor((currentTime - document.RoundStartTime) / 1000);
			// substract the time passed from the roundtime setting (30 secs unless set otherwise)
			document.RoundTime = document.RoundTimeSetting - timePassed;
			// display the current time on the UI
			$("#roundTime").html(document.RoundTime);

			if (document.RoundTime === 6 && !document.animatingVolume) {
				document.animatingVolume = true;
				$("#player").animate({ volume: 0 }, 6000);
			}

			// if in an active round, since a disconnect isnt registered instantly, keep checking if the round is actually already over
			if (document.round > 0 && !document.roundEndInitiated) {
				check_if_all_players_have_guessed();
			}

			if (document.playerFailed) {
				DEBUG && console.log("player failed, skipping song");
				$("#roundTime").hide();
				$("#message").html("Broken song, skipping!");

				skipping = [];
				skipping.push({ type: "skipping" });
				air_console.broadcast(skipping);
				document.roundEndInitiated = true;
				round_end();
			}

			// this generates a whole lot of log lines, because it is calling itself permanently
			// DEBUG && console.log("roundendinitiated: " + document.roundEndInitiated);
			if (document.RoundTime > 0 && document.roundEndInitiated === false) {
				// this generates a whole lot of log lines, because it is calling itself permanently
				// DEBUG && console.log("checking if we are out of time");
				setTimeout(calculateRoundTime, 0);
			} else if (document.roundEndInitiated === false) {
				DEBUG && console.log("out of time");
				// give 30 seconds to everyone who did not guess
				air_console.getControllerDeviceIds().forEach(function (id) {
					// try selecting current score
					playerScore = document.playerScores.filter(function (obj) {
						return obj.player === id;
					});

					if (playerScore[0]) {
						playerScore[0].currentGuessTime = 30;
						playerScore[0].totalGuessTime += 30;
					} else {
						initialize_player_score(id, 0, 30, 30, false);
					}
				});

				// time has run out, tell the remaining controllers to also switch to the round over state
				out_of_time = [];
				out_of_time.push({ type: "out_of_time" });
				air_console.broadcast(out_of_time);
				document.roundEndInitiated = true;
				round_end();
			}
		}

		function controller_boundary_option(type){
			// let the master controller know not to display the corresponding button
			// determine master controller
			master_controller = air_console.getMasterControllerDeviceId();
			// prepare message
			message = [];
			message.push({ type: "boundary", boundary: type });
			// send message to master controller
			air_console.message(master_controller, message);
		}

		function initiateScrollingCheck() {
			// check if the guessing area needs to scroll
			determine_result_area_size();
			// call the function itself again
			if (document.game_in_progress) {
				setTimeout(initiateScrollingCheck, 475);
			}
		}

		document.scroll_in_progress = false;
		document.last_scroll_direction = "left";
		document.last_scroll_ended = new Date().getTime();

		function scroll() {
			currentTime = new Date().getTime();
			timePassed = Math.floor((currentTime - document.last_scroll_ended) / 1000);

			if (document.scroll_results && !document.scroll_in_progress && timePassed >= 1) {
				document.scroll_in_progress = true;
				scrollTime = 1000 * document.overlapping_result_areas;
				scrollDistance = $(".single-result").first().outerWidth(true) * -1 * document.overlapping_result_areas;


				if (document.last_scroll_direction == 'right') {
					$("#results-scrollable").animate({ left: scrollDistance + 'px' }, scrollTime, function () {
						document.last_scroll_direction = "left";
						document.scroll_in_progress = false;
						document.last_scroll_ended = new Date().getTime();
					});
				} else {
					$("#results-scrollable").animate({ left: '0px' }, scrollTime, function () {
						document.last_scroll_direction = "right";
						document.scroll_in_progress = false;
						document.last_scroll_ended = new Date().getTime();
					});
				}
				// console.log("scrolling " + scrollDistance + "px for " + scrollTime + " milliseconds.");
			}
		}

		function determine_result_area_size() {
			// this function checks whether or not we need to make the result area scrollable

			full_window_width = $(window).width();
			// substract the size of the timer
			available_area_width = full_window_width - $("#roundTime").outerWidth(true);

			single_result_area_width = $(".single-result").first().outerWidth(true);
			// console.log("size of one result area: " + single_result_area_width);
			number_of_possible_result_areas = Math.floor(available_area_width / single_result_area_width);
			// console.log("amount of result areas that fit onto the screen before scrolling: " + number_of_possible_result_areas);

			// set the size of the result area so there are no cut off result areas (unless scrolling of course)
			$("#player-results").width(number_of_possible_result_areas * single_result_area_width);
			// also set the margins of the result area, so it is centered on the available space
			// results_margin_left = (available_area_width - $("#player-results").width()) / 2;
			// $("#player-results").css('margin-left', results_margin_left + 'px')
			// console.log("margin: " + results_margin_left);

			number_of_actual_result_areas = $(".single-result").length;
			// console.log("amount of result areas: " +  number_of_actual_result_areas);

			document.overlapping_result_areas = number_of_actual_result_areas - number_of_possible_result_areas;

			// check if a line break is happening
			if (number_of_actual_result_areas > number_of_possible_result_areas) {
				// console.log("line break is happening!");
				// store last amount of overlapping areas for reset purposes
				document.last_overlap_amount = document.overlapping_result_areas;
				if (!document.scroll_in_progress) {
					document.scroll_results = true;
					scroll();
				}
			} else {
				// disable the scrolling
				if (!document.scroll_in_progress && document.last_scroll_direction == "left") {
					document.scroll_in_progress = true;
					// scroll back to initial position
					scrollTime = 1000 * document.last_overlap_amount;
					$("#results-scrollable").animate({ left: '0px' }, scrollTime, function () {
						document.last_scroll_direction = "right";
						document.scroll_in_progress = false;
						document.last_scroll_ended = new Date().getTime();
					});
				}
				document.scroll_results = false;
			}
			// console.log("size of full window: " + full_window_width);	
		}

		function start() {

			DEBUG && console.log("start function initiated");
			document.cancelled = false;

			// reset in case we cancelled an earlier game
			document.roundEndInitiated = false;

			// inform controllers to display get ready
			get_ready = [];
			get_ready.push({ type: "get_ready" });
			air_console.broadcast(get_ready);

			// reset guessing areas
			$("#results-scrollable").html("");

			// create guessing areas for all controllers
			const device_ids = air_console.getControllerDeviceIds();
			device_ids.forEach(function (id) {
				initiate_guessing_area(id);
			});

			// fade logo
			$("#game_logo").hide("fade", {}, 1500);

			sleep(1500).then(() => {

				// show message again (may have been hidden by end of game)
				$("#message").css({ display: "flex" });
				$("#status").css({ display: "flex" });



				$("#message").html("Get ready for the first round!");
				$("#status").html("3");
				document.getElementById("sound-effect-clock").play();


				sleep(1000).then(() => {



					document.getElementById("sound-effect-clock").play();
					$("#status").html("2");
					sleep(1000).then(() => {
						document.getElementById("sound-effect-clock").play();
						$("#status").html("1");
						sleep(1000).then(() => {

							$("#roundCounter").html("Round</br>1/" + document.maxRound);
							$("#playlist-display").html(playlists[document.selectedPlaylist].name);

							$("#status").hide();
							$("#status").html("");

							document.game_in_progress = true;

							// start the function that keeps initiating the check for the result areas
							initiateScrollingCheck();

							// reset scores of players
							document.playerScores = [];

							// reset the roundTime again, at the actual start of the round
							document.RoundTime = document.RoundTimeSetting;
							// also reset the startTime of the current Round so we can keep track of how many seconds have passed
							document.RoundStartTime = new Date().getTime();

							// initiate round time keeptracker
							calculateRoundTime();

							document.round = 0;
							$("#player-results").show();
							$("#roundTime").html(document.RoundTime);
							$("#roundTime").css("display", "flex");

							// override screen with play area
							set_guessing_type_message();
							$("#playanimation").show();
							$("#current_song_service").show();

							document.playerFailed = false;

							DEBUG && console.log("getting ready to call ajax for playlist");
							// get list of songs, choose one at random
							if (playlists[document.selectedPlaylist].id === "666") {
								$.ajax(
									{
										method: "GET",
										url: "https://zxxwemywpv.cyon.link/musicguess-data/php/get_wildcard.php",
										data: {}, dataType: "json", crossDomain: true, "headers": {
											"accept": "application/json",
										}
									})
									.done(function (msg) {
										DEBUG && console.log("ajax for playlist is done");
										library = msg;
										library_copy_for_wrong_answers = library.slice();
										// console.log(library);
										DEBUG && console.log("playing random song for the first time");

										play_random_song();
									})
									.fail(function (msg) {
										DEBUG && console.log("ajax for playlist failed");
										start();
									}
									);
							} else {
								$.ajax(
									{ method: "GET", url: "playlists/playlist_" + playlists[document.selectedPlaylist].id + ".json", data: {}, dataType: "json" })
									.done(function (msg) {
										DEBUG && console.log("ajax for playlist is done");
										library = msg;
										library_copy_for_wrong_answers = library.slice();
										// console.log(library);
										DEBUG && console.log("playing random song for the first time");

										play_random_song();
									})
									.fail(function (msg) {
										DEBUG && console.log("ajax for playlist failed");
										start();
									}
									);
							}

							var playlist_id = playlists[document.selectedPlaylist].id;
							DEBUG && console.log("trying to send playlist selected event");
							$.ajax(
								{
									method: "POST",
									url: "https://zxxwemywpv.cyon.link/musicguess-data/php/playlist-selected.php",
									data: { devices: air_console.devices, playlist_id: playlist_id, number_of_rounds: document.maxRound }, dataType: "json", crossDomain: true, "headers": {}
								});


							// stores the current solution
							document.solution = [];
						});
					});
				});
			});
		}

		// Array Remove - By John Resig (MIT Licensed)
		Array.prototype.remove = function (from, to) {
			var rest = this.slice((to || from) + 1 || this.length);
			this.length = from < 0 ? this.length + from : from;
			return this.push.apply(this, rest);
		};

		function randomIntFromInterval(min, max) {
			return Math.floor(Math.random() * (max - min + 1) + min);
		}

		/* function update_controllers_about_game_status(){
		message = [];
		if (document.game_in_progress) {
			// let the existing controllers know the game is running
			
			message.push({
				type: "in_progress"
			});
			
		} else {
			// let the existing controllers know the game is not running
			message.push({
				type: "not_in_progress"
			});
		}
		air_console.broadcast(message);
		} */

		function play_random_song() {
			DEBUG && console.log("play random song was called");
			document.round++;
			DEBUG && console.log("increased round counter");
			$("#roundCounter").html("Round</br>" + document.round + "/" + document.maxRound);
			DEBUG && console.log("set round counter display");

			// test if the start function can be invoked in case of library not being loaded successfully from ajax
			// it does, just not very nicely
			/* randonum = randomIntFromInterval(0,1);
			if(randonum === 0){
				console.log("bugging out");
				library = undefined;
			} else {
				console.log("working");
			} */
			DEBUG && console.log("library:");
			DEBUG && console.log(library);
			if (library === undefined) {
				// attempt to start over
				DEBUG && console.log("starting over because library was not returned from ajax");
				start();
				return;
			}

			randomSongIndex = randomIntFromInterval(0, library.length - 1);
			DEBUG && console.log("got id of random song");
			randomSong = library[randomSongIndex];

			// use this to select a specific song
			/* library.forEach((track) => {
				if(track.id === '1054438586'){
					randomSong = track;
				}
			}); */

			DEBUG && console.log("random song:");
			DEBUG && console.log(randomSong);

			DEBUG && console.log("got the random song object");
			// remove song from the library so it will not get played more than once
			library.remove(randomSongIndex);
			DEBUG && console.log("removed the random song from the library");

			// get wrong answers for multiple choice
			wrong_answers = 0;
			wrong_answers_array = [];

			switch (document.guessing_type) {
				case "guessing-both":
					artist_or_title = randomIntFromInterval(0, 1);
					break;
				case "guessing-artist":
					artist_or_title = 0;
					break;
				case "guessing-title":
					artist_or_title = 1;
					break;
			}

			DEBUG && console.log("determined whether to let the user guess artist or title");

			DEBUG && console.log("entering while loop");

			while (wrong_answers < 3) {

				// 50:50 chance that wrong answer is either artist or title

				suitable_wrong_answer = true;
				wrongSongIndex = randomIntFromInterval(0, library_copy_for_wrong_answers.length - 1);

				// console.log("wrong song index " + wrongSongIndex);

				wrongSong = library_copy_for_wrong_answers[wrongSongIndex];
				if (artist_or_title === 0) {
					// artist
					// check if the wrongSong has the same artist as the actual song
					if (wrongSong === undefined || randomSong === undefined) {
						suitable_wrong_answer = false;
					} else if (wrongSong.artist === randomSong.artist) {
						suitable_wrong_answer = false;
					}
					// check if wrong contains right, or vice versa
					if (wrongSong.artist.indexOf(randomSong.artist) !== -1 && randomSong.artist.indexOf(wrongSong.artist)) {
						suitable_wrong_answer = false;
					}
					// check if the selection is already in the array
					if ($.inArray(wrongSong.artist, wrong_answers_array) !== -1) {
						suitable_wrong_answer = false;
					}
					if (suitable_wrong_answer) {
						wrong_answers_array.push(wrongSong.artist);
					}
				} else {
					// title
					// check if the wrongSong has the same title as the actual song
					if (wrongSong.title === randomSong.title) {
						suitable_wrong_answer = false;
					}
					// check if wrong contains right, or vice versa
					if (wrongSong.title.indexOf(randomSong.title) !== -1 && randomSong.title.indexOf(wrongSong.title) !== -1) {
						suitable_wrong_answer = false;
					}
					// check if the selection is already in the array
					if ($.inArray(wrongSong.title, wrong_answers_array) !== -1) {
						suitable_wrong_answer = false;
					}
					if (suitable_wrong_answer) {
						wrong_answers_array.push(wrongSong.title);
					}
				}
				if (suitable_wrong_answer) {
					wrong_answers++;
				}
			}

			// console.log("array of wrong answers" + wrong_answers_array);

			// console.log("playing song " + randomSongIndex + " in library");
			// console.log(randomSong);

			// change song id in player
			$("#player").attr("src", randomSong.preview_url);

			// turn volume back up
			DEBUG && console.log("resetting player volume");
			document.animatingVolume = false;
			player = document.getElementById("player");
			player.volume = 0.4;

			// apparently this is broken?
			// $("#player").prop("volume", 0.4);


			// record start time
			document.startTime = new Date().getTime();


			// $('#player').get(0).currentTime = 5;
			$("#playanimation").show();
			DEBUG && console.log("triggered the bars animation");


			artist = randomSong.artist;
			title = randomSong.title;
			album = randomSong.album;
			album_art = randomSong.album_art;
			buy_link = randomSong.buy_link;

			$("#current_song_service").html("<div id='disclaimer'>This song is provided by the Itunes Search API Preview</div><div id='get_it_link'><a href='" + buy_link + "'' target='_blank'><img src='images/itunes.svg' class='itunes' /></a></div>");



			document.solution = [];
			document.solution.push({
				type: "solution",
				artist: artist,
				title: title,
				album: album,
				album_art: album_art,
				wrongAnswers: wrong_answers_array,
				answerType: artist_or_title,
				buy_link: buy_link
			});

			// send the solution to all clients
			air_console.broadcast(document.solution);
		}

		function switch_playlist(type) {
			DEBUG && console.log("switching playlist");
			// console.log("Handling switch of playlist to " + type);
			// console.log("all playlists:");
			// console.log(playlists);

			// $(".album_art.active").addClass("shrink");


			document.getElementById("sound-effect-switch").play();

			if (type === "next") {
				// currently on the last playlist
				if (document.selectedPlaylist === playlists.length - 1) {
					document.selectedPlaylist = 0;
					previous_id = playlists.length - 1;
					next_id = 1;
				} else if (document.selectedPlaylist === playlists.length - 2) {
					DEBUG && console.log("we are on the second last playlist before the switch");
					previous_id = playlists.length - 2;
					document.selectedPlaylist = playlists.length - 1;
					next_id = 0;
				} else {
					previous_id = document.selectedPlaylist;
					document.selectedPlaylist += 1;
					next_id = document.selectedPlaylist + 1;
				}
			} else {
				// previous
				// currently on the first playlist
				if (document.selectedPlaylist === 0) {
					previous_id = playlists.length - 2;
					document.selectedPlaylist = playlists.length - 1;
					next_id = 0;
				} else if (document.selectedPlaylist === 1) {
					next_id = 1;
					document.selectedPlaylist = 0;
					previous_id = playlists.length - 1;
				}
				else {
					next_id = document.selectedPlaylist;
					document.selectedPlaylist -= 1;
					previous_id = document.selectedPlaylist - 1;
				}
			}

			$(".album_art.previous").html(document.playlist_storage[previous_id]);
			$(".album_art.active").html(document.playlist_storage[document.selectedPlaylist]);

			$(".playlist-track-count").html(playlists[document.selectedPlaylist]['amount_of_tracks'] + " Tracks");
			$(".playlist-description").html(playlists[document.selectedPlaylist]['description']);


			$(".album_art.next").html(document.playlist_storage[next_id]);

			if (document.maxRound > playlists[document.selectedPlaylist]['amount_of_tracks']) {
				document.maxRound = playlists[document.selectedPlaylist]['amount_of_tracks'];
			}

			check_if_playlist_needs_hero();

			update_max_rounds_on_controllers();

			// console.log("newly selected playlist" + document.selectedPlaylist);

		}
		function update_selected_rounds_on_controllers() {
			round_change = [];
			round_change.push({ type: "round_change", maxRound: document.maxRound });
			// send round change message to the controllers
			air_console.broadcast(round_change);
		}

		function update_max_rounds_on_controllers() {
			// also send the current playlist max rounds to the controllers, so it knows when not to increase the count locally
			if (typeof playlists !== 'undefined' && document.selectedPlaylist !== undefined) {
				// only attempt this is playlists is already initialized (takes some time because the json needs to be fetched first)
				playlist_rounds = [];
				playlist_rounds.push({ type: "playlist_rounds", playlist_rounds: playlists[document.selectedPlaylist]['amount_of_tracks'] });
				air_console.broadcast(playlist_rounds);
			}
		}

		function sleep(ms) {
			return new Promise(resolve => setTimeout(resolve, ms));
		}

		function check_if_playlist_needs_hero() {
			if (document.screen !== "playlist-selection") {
				return;
			}
			if (playlists[document.selectedPlaylist]['hero'] === "1") {
				DEBUG && console.log("playlist requires hero");
				if (document.hero) {
					DEBUG && console.log("user has hero, show start with hero");
					start_with_hero = [];
					start_with_hero.push({ type: "start_with_hero" });
					air_console.broadcast(start_with_hero);
				} else {
					DEBUG && console.log("user does not hero, disabling start");
					disable_start = [];
					disable_start.push({ type: "disable_start" });
					air_console.broadcast(disable_start);
				}
			} else {
				DEBUG && console.log("playlist does not require hero, enabling start");
				enable_start = [];
				enable_start.push({ type: "enable_start" });
				air_console.broadcast(enable_start);
			}
		}

		function send_score() {
			document.playerScores.forEach(function (score) {
				DEBUG && console.log("sending score to player " + score.player);
				DEBUG && console.log(score);
				score_message = [];
				score_message.push({ type: "score", score: score, maxRound: document.maxRound });
				air_console.message(score.player, score_message);
			});
		}

		function round_end() {
			/* if (document.ad_showing) {
				document.roundEndInitiated = false;
				return;
			} */

			hide_cancel = [];
			hide_cancel.push({ type: "hide_cancel" });
			air_console.broadcast(hide_cancel);

			DEBUG && console.log("round end function was called");

			// determine fastest player
			// clone array for sorting differently
			fastestPlayers = document.playerScores.slice();

			fastestPlayers.sort(function (a, b) {
				if (a.currentGuessTime < b.currentGuessTime) {
					if (a.correct) {
						// place a higher than b
						return -1;
					} else if (b.correct) {
						// place b higher than a
						return 1;
					} else {
						// place a higher than b
						return -1;
					}
				}
				if (a.currentGuessTime > b.currentGuessTime) {
					if (b.correct) {
						// place b higher than a
						return 1;
					} else if (a.correct) {
						// place a higher than b
						return -1;
					} else {
						// place b higher than a
						return 1;
					}
				}
				// place and b "equally"
				if (a.correct && b.correct) {
					return 0;
				}
				if (!a.correct && !b.correct) {
					return 0;
				}
				if (a.correct) {
					// place a higher than b
					return -1;
				} else {
					// place b higher than a
					return 1;
				}

			});
			if (typeof fastestPlayers !== 'undefined' && typeof fastestPlayers[0] !== 'undefined' && fastestPlayers[0].correct) {
				fastestString = "Fastest player: " + air_console.getNickname(fastestPlayers[0].player) + " with " + fastestPlayers[0].currentGuessTime + " seconds.";
			} else if (document.playerFailed) {
				fastestString = "We apologize for the inconvenience.";
			} else {
				fastestString = "Nobody guessed correctly!";
			}
			// output fastest player to screen
			$("#status").css({ display: "flex" });
			$("#status").html(fastestString);
			// console.log(fastestString);

			// stop animations in progress
			// $("#player").stop();

			// reset the roundTime so time cant run out in the time between matches
			document.RoundTime = document.RoundTimeSetting;
			$("#roundTime").hide();

			$("#current_song_service").hide();

			$("#playanimation").hide();

			if (document.playerFailed) {
				document.playerFailed = false;
				$("#message").html("Skipped a broken song.");
				$("#roundTime").hide();
				$("#playanimation").hide();
			} else {
				if (!document.animatingVolume) {
					$("#player").animate({ volume: 0 }, 4000);
					document.animatingVolume = true;
				}

				$("#message").html("Round is over!");
			}

			sleep(4000).then(() => {



				document.amount_of_finished_players = 0;

				// remove correct/wrong classes - we wait for the timer to pass because otherwise the last players result wont get highlighted on the screen
				$(".darken_image").removeClass("avatar_wrong");
				$(".darken_image").removeClass("avatar_correct");

				if (document.round === document.maxRound) {
					// reset current round to 0 so no part of the game thinks we are still in a game
					document.round = 0;

					// handle end of game
					document.game_in_progress = false;
					document.game_over_screen = true;

					// let every player know their score for their after game report
					document.playerScores.forEach(function (score) {
						DEBUG && console.log("sending score to player " + score.player);
						DEBUG && console.log(score);
						score_message = [];
						score_message.push({ type: "score_report", score: score, maxRound: document.maxRound });
						air_console.message(score.player, score_message);
					});

					$("#roundCounter").hide();
					$("#roundCounter").html("");

					$("#playlist-display").hide();

					$("#status").html("");
					$("#status").hide();
					const winner_object = document.playerScores[0];
					let message = '';
					if (winner_object !== undefined) {
						const winner = air_console.getNickname(winner_object.player);
						const winner_correct = winner_object.correctGuesses;

						const winner_html = $("#results-scrollable .single-result").first();
						$("#victory_screen").append("<span class='game_over'> Game Over! Winner:</span>");
						$("#victory_screen").append(winner_html);

						$("#victory_screen .position_display").hide();
						$("#victory_screen .darken_image").hide();
						$("#victory_screen .player_score").append(" points");


						message += "<span class='result_category'>Correct guesses:</span>";
						message += "<span class='result'>" + winner_correct + "/" + document.maxRound + " (" + Math.round(100 / document.maxRound * winner_correct) + "%)</span></br>";
						message += "<span class='result_category'>Total time taken for guesses:</span>";
						message += "<span class='result'>" + Math.round(winner_object.totalGuessTime * 10) / 10 + " seconds</span></br>";
						message += "<span class='result_category'>Average time guessing:</span>";
						message += "<span class='result'>" + + Math.round(winner_object.totalGuessTime / document.maxRound * 10) / 10 + " seconds</span></br>";

						$("#victory_screen").append(message);

						$("#message").html("");
						$("#message").hide();
						$("#status").hide();

						$("#victory_screen").css({ display: "flex" });
						$("#victory_screen").animate({ opacity: 0.9 }, 1500);
						$("#player-results").hide();



						document.getElementById("sound-effect-cheers").play();
					} else {
						message = "Game Over!</br> You have managed to never even guess. Either you're away from the game or you're testing an edge case ;)</br>";
						$("#message").html(message);
					}


					// set roundTime extra high so the end doesnt happen more than once
					document.RoundTime = -10;
					// console.log("game over");

					$("#current_song_service").hide();

					game_end = [];
					game_end.push({ type: "game_end" });
					document.roundEndInitiated = false;
					// send game end message to the controllers
					air_console.broadcast(game_end);
				} else if (!document.cancelled) {
					air_console.showAd();
				}
			});
		}

		function next_round() {
			// stop the volume from going down
			// $("#player").stop();

			document.roundEndInitiated = false;
			// initiate next round
			// reset the number of inactive clients (clients that connect in this time can play the next round)
			document.inactiveClients = 0;
			$("#message").html("Get ready for the next round!");
			$("#status").css({ display: "flex" });
			$("#status").html("3");
			document.getElementById("sound-effect-clock").play();
			sleep(1000).then(() => {
				document.getElementById("sound-effect-clock").play();
				$("#status").html("2");
				sleep(1000).then(() => {
					document.getElementById("sound-effect-clock").play();
					$("#status").html("1");
					sleep(1000).then(() => {
						$("#current_song_service").show();
						$("#status").html("");
						$("#status").hide();

						set_guessing_type_message();



						// reset the roundTime again, at the actual start of the round
						document.RoundTime = document.RoundTimeSetting;
						// also reset the startTime of the current Round so we can keep track of how many seconds have passed
						document.RoundStartTime = new Date().getTime();

						// reset the guessTime and correct/false for every player in case they dont answer
						document.playerScores.forEach(function (element) {
							element.correct = false;
							element.currentGuessTime = 0;
						});

						// initiate round time keeptracker
						document.roundEndInitiated = false;
						DEBUG && console.log("start keeping track of roundtime");
						calculateRoundTime();

						$("#roundTime").css("display", "flex");
						DEBUG && console.log("calling play random song for next round");
						play_random_song();
					});
				});
			});
		}



		function initiate_guessing_area(player_id) {
			// check if the player already has a guess area
			guessArea = false;
			$("#player_" + player_id + "_result").each(function () {
				guessArea = true;
			});
			if (!guessArea) {
				// determine nickname of player
				nickname = air_console.getNickname(player_id);
				// add empty guessArea
				url = air_console.getProfilePicture(player_id, 120);
				$("#results-scrollable").append('<div class="single-result" id="player_' + player_id + '_result"><div class="position_display"></div><div class="darken_image"></div><img src="' + url + '"><div class="player_name">' + nickname + '</div><div class="player_score"></div>');

			}
		}

		function initialize_player_score(from, newScore, guessTime, guessTime, correct) {
			if (correct) {
				document.playerScores.push({ player: from, score: newScore, currentGuessTime: guessTime, totalGuessTime: guessTime, correct: correct, correctGuesses: 1 });
			} else {
				document.playerScores.push({ player: from, score: newScore, currentGuessTime: guessTime, totalGuessTime: guessTime, correct: correct, correctGuesses: 0 });
			}
		}

		function handle_guess(message, from) {

			// console.log("Player " + from + " made a guess!");

			// initialize the array that stores the general progress of the players
			if (!document.player) {
				document.player = [];
			}

			// initialize the array for the current device
			if (!document.player[from]) {
				// initialize array if not already present
				document.player[from] = [];
			}

			initiate_guessing_area(from);

			guessTime = (new Date().getTime() - document.startTime);
			negative_points = Math.round(0.01 * guessTime);

			actual_points = 300 - negative_points;
			if (actual_points < 0) actual_points = 0;
			guessTime = guessTime / 1000;

			correct = true;
			if (message[0].type !== "correctGuess") {
				actual_points = 0;
				correct = false;
			}

			newScore = actual_points;

			// try selecting current score
			playerScore = document.playerScores.filter(function (obj) {
				return obj.player === from;
			});

			let correctGuesses = 0;
			let totalGuessTime = 0;
			if (playerScore[0]) {
				newScore = playerScore[0].score + actual_points;
				playerScore[0].score = newScore;
				playerScore[0].currentGuessTime = guessTime;
				playerScore[0].correct = correct;
				playerScore[0].totalGuessTime += guessTime;
				totalGuessTime = playerScore[0].totalGuessTime;
				if (correct) {
					playerScore[0].correctGuesses++;
					correctGuesses = playerScore[0].correctGuesses;
				}
			} else {
				totalGuessTime = guessTime;
				if (correct) {
					correctGuesses = 1;
				}
				initialize_player_score(from, newScore, guessTime, guessTime, correct);
			}

			document.playerScores.sort(function (a, b) {
				if (a.score > b.score) {
					return -1;
				}
				if (a.score < b.score) {
					return 1;
				}
				return 0;
			});

			let position = 0;
			document.playerScores.forEach(function (score, index) {
				if (score.player === from) {
					position = index + 1;
				}
				score.position = index + 1;
			});

			$("#player_" + from + "_result .player_score").html(newScore);

			// send the score to the controller
			document.score = [];
			document.score.push({
				type: "score",
				score: { score: newScore, increase: actual_points, position: position }
			});
			// send the score to the specific client
			air_console.message(from, document.score);

			// console.log(document.playerScores);



			// console.log(document.playerScores);

			url = air_console.getProfilePicture(from, 120);
			resultArea = $("#player_" + from + "_result");
			resultArea.find("img").attr("src", url);

			position = 1;
			document.playerScores.forEach(function (element) {
				$("#player_" + element.player + "_result").find(".position_display").html(position + ".");

				if (position === 1) {
					$("#player_" + element.player + "_result").prependTo("#results-scrollable");
				} else {
					// insert after previous element
					$("#player_" + element.player + "_result").insertAfter("#player_" + previous_element.player + "_result");
				}
				previous_element = element;
				position++;
			});

			if (message[0].type === "correctGuess") {
				resultArea.find(".current_score").html(newScore);
				resultArea.find(".score_change").html("+ " + actual_points + " Points");
				resultArea.find(".current_time").html(guessTime + " seconds");
				resultArea.find(".darken_image").addClass("avatar_correct");
			} else {
				resultArea.find(".score_change").html("No Points");
				resultArea.find(".current_time").html(guessTime + " seconds");
				resultArea.find(".darken_image").addClass("avatar_wrong");
				actual_points = 0;
			}

			// increase the amount of finished players
			document.amount_of_finished_players++;

			DEBUG && console.log("handle_guess is calling check if all players have guessed");
			check_if_all_players_have_guessed();
			send_score();
		}

		function check_if_all_players_have_guessed() {
			// console.log("Currently Connected: " + air_console.getControllerDeviceIds().length);
			// console.log("Amount of finished players: " + document.amount_of_finished_players);
			// console.log("Amount of inactive clients: " + document.inactiveClients);
			// in theory this should play the next song when all connected devices have finished
			// since a controller can join after the round has started, this is probably a blocker we need to handle
			if (document.amount_of_finished_players === air_console.getControllerDeviceIds().length) {
				DEBUG && console.log("currently connected player amount: " + air_console.getControllerDeviceIds().length);
				DEBUG && console.log("all connected controllers have finished their guess");
				document.roundEndInitiated = true;
				round_end();

			}
			// check if the total is correct when considering inactive players
			else if (air_console.getControllerDeviceIds().length === document.amount_of_finished_players + document.inactiveClients) {
				DEBUG && console.log("all connected controllers have finished their guess, considering inactive controllers");
				document.roundEndInitiated = true;
				round_end();
			}
		}


	</script>

</head>

<body onload="init()">
	<div id="screen-wrapper">
		<div class="instruction logo">
			<span id="game_logo">MusicGuess</span>
			<span id="message"></span>
		</div>
		<div id="status-wrapper">
			<span id="status"></span>
		</div>
		<div id="current_song_service"></div>
		<div id="victory_screen"></div>
	</div>
	<div id="playlist-selector">
		<div class="dialogue-wrapper">
			<div class="dialogue">
				Select your playlist!
			</div>
		</div>
	</div>
	<div id="playlist-display"></div>
	<div id="roundCounter"></div>
	<div id="roundTime"></div>
	<div id="credits-container">
		<div id="credits">
			<span class="category">Developed by:</span>
			<span class="content">Christian Nyffenegger, <a
					onclick="air_console.openExternalUrl('https://twitter.com/freakpants')" target="_blank"
					href="https://twitter.com/freakpants">freakpants</a></span></br>
			<span class="category">Background video by:</span>
			<span class="content"><a target="_blank"
					href="https://pixabay.com/de/users/tommyvideo-3092371/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=5154">Tomislav
					Jakupec</a> / <a target="_blank"
					href="https://pixabay.com/de/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=5154">Pixabay</a></span></br>
			<span class="category">Music provided by:</span>
			<span class="content"><a target="_blank"
					href="https://developer.apple.com/library/archive/documentation/AudioVideo/Conceptual/iTuneSearchAPI/index.html">Itunes
					Search API Preview</a></span></br>
			<span class="category">Sound effects by:</span>
			<span class="content"><a target="_blank" href="https://www.zapsplat.com">Zapsplat</a></span></br>
			<span class="category">SVG Loaders by:</span>
			<span class="content"><a target="_blank" href="https://twitter.com/sherb">Sam Herbert</a> (<a
					target="_blank" href="https://github.com/SamHerbert/SVG-Loaders">Github</a>)</span></br>
		</div>
	</div>
	<div id="updates-container">
		<div id="updates">
			<ul>
				<li>15.12.2021 - Released new wildcard playlist. This dynamically selects from over 30'000 songs, but
					with a lot of cover/live versions of songs or just plain unknown or weird songs.</li>
				<li>16.12.2021 - Fixed an Issue with wildcard playlist not working.</li>
				<li>20.12.2021 - Released a new christmas playlist</li>
				<li>04.01.2022 - The game is now playable for free. Accordingly, some playlists are now exclusive with
					AirConsole Hero.
					There is a new menu system, with improved selection of round amount. Released 3 new playlists:
					Ballads, Latin, Spain's Most Wanted Dec 2021. Added 10 new songs to Global Hits 2021.
				</li>
			</ul>
		</div>
	</div>
	<div id="splash-screen">
		<div id="splash-text">
			Welcome to MusicGuess! MusicGuess is a living game that is constantly being updated with new content and
			features.
			To see the latest update, select Updates in the menu. If you want to give feedback/report issues you can
			follow the official Twitter account
			@MusicGuess1 </br>
			I would also love to see pictures of your parties (especially those really big ones with over 10 players and
			more!).
			</br></br>
			Enjoy the game and have fun!</br>
			@freakpants
		</div>
	</div>
	<div id="spotify-container">
		<div id="spotify">
			<span>You need to be on a computer to connect Spotify.
				The Spotify account will be connected to the AirConsole user on the current Master Controller.
				Currently, this user is <span id="master-user"></span></br>
				Press Confirm/Start to open a new window to attempt to connect your Spotify Account.
			</span>
		</div>
	</div>
	<div id="main-menu">
		<ul>
			<li id="new-game-button" class="active">
				New Game
			</li>
			<li id="credits-button">
				Credits
			</li>
			<li id="updates-button">
				Updates
			</li>
			<li id="connect-spotify-button">
				Connect with Spotify
			</li>
		</ul>
		<div id="ticker-wrapper">
			<div class="ticker" id="ticker1">Follow @MusicGuess1 on Twitter to get updates and give feedback about the
				game!</div>
			<div class="ticker" id="ticker2">There is 1 new playlist, Today's Top 50!</div>
		</div>

	</div>
	<div id="default-options">
		<div class="dialogue">
			Do you want to play the game with the default options? (20 rounds)
		</div>
		<ul>
			<li id="default-yes" class="active">
				Yes
			</li>
			<li id="default-no">
				No
			</li>
		</ul>
	</div>
	<div id="specific-options">
		<div class="dialogue">
			<!-- dialogue is set by variable, as it gets changed and changed back again when going to a specific option -->
		</div>
		<ul id="option-selector">
			<li id="round_amount_option" class="active">
				Number of Rounds to play
			</li>
			<li id="guessing_type">
				Randomly guess either artist or title each round
			</li>
			<li id="specific-start">
				Start
			</li>
		</ul>
		<ul id="round-amount-selector">
			<li>1</li>
			<li>10</li>
			<li>15</li>
			<li>20</li>
			<li>25</li>
			<li>30</li>
			<li>40</li>
			<li>50</li>
			<li>100</li>
			<li>Custom Amount</li>
		</ul>
		<ul id="guessing-type-selector">
			<li id="guessing-artist" class="active">Always guess the artist</li>
			<li id="guessing-title">Always guess the title</li>
			<li id="guessing-both">Randomly guess either artist or title each round</li>
		</ul>
	</div>
	<div id="player-results">
		<div id="results-scrollable"></div>
	</div>
	<audio id="sound-effect-switch">
		<source src="sounds/switch.mp3" type="audio/mpeg">
	</audio>
	<audio id="sound-effect-clock">
		<source src="sounds/clock.mp3" type="audio/mpeg">
	</audio>
	<audio id="sound-effect-correct">
		<source src="sounds/correct.mp3" type="audio/mpeg">
	</audio>
	<audio id="sound-effect-wrong">
		<source src="sounds/error.mp3" type="audio/mpeg">
	</audio>
	<audio id="sound-effect-cheers">
		<source src="sounds/cheers.mp3" type="audio/mpeg">
	</audio>
	<audio id="sound-effect-click">
		<source src="sounds/click.mp3" type="audio/mpeg">
	</audio>
	<audio id="sound-effect-start">
		<source src="sounds/start.mp3" type="audio/mpeg">
	</audio>

	<audio id="player" autoplay>
		<source src="" type="audio/mpeg">
	</audio>
</body>